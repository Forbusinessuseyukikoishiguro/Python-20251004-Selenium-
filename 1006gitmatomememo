# Git & GitHub チーム開発ガイド 🚀

新人エンジニアさん、ようこそ! Windows環境でのGit操作を丁寧に説明しますね。

---

## 1️⃣ リバート vs リベース

### 🔄 **リバート (Revert)**
特定のコミットの変更を**打ち消す新しいコミット**を作成

```bash
# 特定のコミットを取り消す
git revert <コミットハッシュ>

# 例: 最新のコミットを取り消す
git revert HEAD

# 複数のコミットを取り消す
git revert HEAD~3..HEAD
```

**特徴:**
- ✅ 履歴を残す(安全)
- ✅ 共有ブランチで使える
- ✅ チーム開発向き

---

### 🔀 **リベース (Rebase)**
コミット履歴を**付け替えて整理**する

```bash
# mainブランチの最新を取り込む
git checkout feature/login
git rebase main

# インタラクティブモード(コミットを整理)
git rebase -i HEAD~3

# リベース中止
git rebase --abort

# 競合解決後に続行
git rebase --continue
```

**特徴:**
- ⚠️ 履歴を書き換える
- ❌ プッシュ済みブランチでは使わない
- ✅ ローカルで履歴を綺麗にする時に使う

---

## 2️⃣ チェリーピック (Cherry-pick)

特定のコミットだけを**別のブランチに持ってくる**

```bash
# 特定のコミットを現在のブランチに適用
git cherry-pick <コミットハッシュ>

# 複数のコミットを適用
git cherry-pick abc123 def456

# 競合時の対応
git cherry-pick --continue  # 解決後
git cherry-pick --abort     # 中止
```

**使用例:**
```bash
# hotfixをmainとdevelopの両方に適用
git checkout main
git cherry-pick hotfix-commit-hash

git checkout develop
git cherry-pick hotfix-commit-hash
```

**注意点:**
- ⚠️ 同じ変更が複数ブランチに存在(重複コミット)
- 緊急バグ修正でよく使う

---

## 3️⃣ ブランチ命名規則 & コマンド

### 📋 **一般的なブランチ名**

| ブランチ名 | 用途 | 例 |
|----------|------|-----|
| `main` / `master` | 本番環境 | `main` |
| `develop` | 開発統合 | `develop` |
| `feature/*` | 新機能開発 | `feature/login-page` |
| `bugfix/*` | バグ修正 | `bugfix/header-layout` |
| `hotfix/*` | 緊急修正 | `hotfix/security-patch` |
| `release/*` | リリース準備 | `release/v1.2.0` |

---

### 💻 **基本コマンド集**

```bash
# ========== ブランチ作成・切り替え ==========
# 新しいブランチを作成して切り替え
git checkout -b feature/user-profile

# ブランチ切り替え
git checkout develop

# ブランチ一覧表示
git branch          # ローカル
git branch -r       # リモート
git branch -a       # 全て

# ========== リモート連携 ==========
# ローカルブランチをリモートにプッシュ
git push -u origin feature/user-profile

# リモートの最新を取得
git fetch origin

# リモートの変更を取り込む
git pull origin develop

# ========== マージ ==========
# developに戻ってfeatureをマージ
git checkout develop
git merge feature/user-profile

# マージ後にリモートに反映
git push origin develop

# ========== ブランチ削除 ==========
# ローカルブランチ削除
git branch -d feature/user-profile

# 強制削除(マージされてなくても)
git branch -D feature/user-profile

# リモートブランチ削除
git push origin --delete feature/user-profile
```

---

### ⚠️ **気をつけること**

```bash
# ❌ 間違い: mainブランチで直接作業
git checkout main
# 作業...

# ✅ 正解: featureブランチを作る
git checkout main
git pull origin main
git checkout -b feature/new-function

# ❌ 間違い: コミット前にpull
# (作業中の変更が消える可能性)

# ✅ 正解: 先にコミットorスタッシュ
git add .
git commit -m "作業中"
git pull origin develop

# または
git stash
git pull origin develop
git stash pop
```

---

## 4️⃣ コンフリクト解消 (ステップバイステップ)

### 🔴 **コンフリクト発生のシナリオ**

```bash
# Aさんとあなたが同じファイルを編集
# あなたがpullした時に競合発生
git pull origin develop
```

**エラーメッセージ:**
```
Auto-merging app.py
CONFLICT (content): Merge conflict in app.py
Automatic merge failed; fix conflicts and then commit the result.
```

---

### 📝 **解消手順**

#### **Step 1: 競合ファイルを確認**
```bash
# 競合しているファイル一覧
git status
```

出力例:
```
Unmerged paths:
  (use "git add <file>..." to mark resolution)
        both modified:   app.py
```

---

#### **Step 2: ファイルを開いて編集**

PyCharmまたはVSCodeで `app.py` を開くと:

```python
<<<<<<< HEAD (あなたの変更)
def calculate(a, b):
    return a + b
=======
def calculate(x, y):
    return x * y
>>>>>>> origin/develop (リモートの変更)
```

**編集後:**
```python
# どちらを採用するか決める、または両方を統合
def calculate(a, b):
    return a + b  # 足し算を採用
```

---

#### **Step 3: 解決をマーク**
```bash
# 編集が終わったらaddする
git add app.py

# 全ての競合ファイルを確認
git status
```

---

#### **Step 4: コミット**
```bash
# マージコミットを作成
git commit -m "Merge conflict resolved"

# またはメッセージ無しで(自動生成される)
git commit
```

---

#### **Step 5: プッシュ**
```bash
git push origin develop
```

---

### 🛠️ **便利なGitコマンド**

```bash
# ========== 競合解消の補助 ==========
# 競合を中止して元に戻す
git merge --abort
git rebase --abort

# こちら側を優先
git checkout --ours app.py
git add app.py

# 相手側を優先
git checkout --theirs app.py
git add app.py

# ========== マージツールを使う ==========
git mergetool

# ========== 差分確認 ==========
# 競合部分を確認
git diff

# ブランチ間の差分
git diff develop feature/login
```

---

### 🎯 **PyCharmでの競合解決**

PyCharmには優秀なマージツールがあります:

1. **VCS → Git → Resolve Conflicts**
2. 3つのパネルが表示:
   - 左: あなたの変更
   - 中央: 結果
   - 右: リモートの変更
3. `>>` または `<<` ボタンで選択
4. **Apply** で完了

---

## 📚 **実践的なワークフロー例**

```bash
# 1. 最新のdevelopを取得
git checkout develop
git pull origin develop

# 2. 作業用ブランチを作成
git checkout -b feature/add-search

# 3. 作業してコミット
git add .
git commit -m "Add search functionality"

# 4. developの最新を取り込む(リベース)
git fetch origin
git rebase origin/develop

# 5. 競合があれば解決
# ... (上記の手順)
git add .
git rebase --continue

# 6. リモートにプッシュ
git push -u origin feature/add-search

# 7. GitHubでPull Request作成

# 8. レビュー後、マージされたらローカルを更新
git checkout develop
git pull origin develop

# 9. 作業ブランチを削除
git branch -d feature/add-search
git push origin --delete feature/add-search
```

---

## 🎓 **まとめ: 新人が覚えるべき順序**

1. **基本**: `add`, `commit`, `push`, `pull`
2. **ブランチ**: `checkout -b`, `merge`
3. **競合解決**: 落ち着いて1ファイルずつ
4. **応用**: `rebase`, `cherry-pick`, `revert`

わからないことがあれば、いつでも質問してください! 🙌


# 🚀 Git & GitHub チートシート - 完全版

## 📦 初期設定

### Gitのインストール確認
```bash
git --version
```

### 初回設定(必須)
```bash
# ユーザー名を設定
git config --global user.name "あなたの名前"

# メールアドレスを設定
git config --global user.email "your.email@example.com"

# 設定確認
git config --list

# エディタ設定(VSCode使う場合)
git config --global core.editor "code --wait"
```

---

## 🆕 リポジトリの作成

### ローカルで新規作成
```bash
# 新しいフォルダを作成して初期化
mkdir my-project
cd my-project
git init

# 現在のフォルダを初期化
git init
```

### GitHubから複製(クローン)
```bash
# HTTPSでクローン
git clone https://github.com/username/repository.git

# SSHでクローン
git clone git@github.com:username/repository.git

# 特定のフォルダ名でクローン
git clone https://github.com/username/repository.git my-folder
```

---

## 📝 基本的な作業フロー

### 1. ファイルの変更を確認
```bash
# 変更されたファイルを確認
git status

# 詳細な差分を表示
git diff

# ステージングエリアの差分
git diff --staged
```

### 2. ファイルをステージング
```bash
# 特定のファイルを追加
git add file.txt

# 複数ファイルを追加
git add file1.txt file2.txt

# 全てのファイルを追加
git add .

# 全ての変更(削除含む)を追加
git add -A

# 対話的に追加
git add -p
```

### 3. コミット
```bash
# コミット(エディタが開く)
git commit

# メッセージ付きでコミット
git commit -m "コミットメッセージ"

# add + commit を一度に(追跡中のファイルのみ)
git commit -am "メッセージ"

# コミットメッセージを修正
git commit --amend -m "修正したメッセージ"
```

### 4. リモートにプッシュ
```bash
# リモートにプッシュ
git push origin main

# 初回プッシュ(upstream設定)
git push -u origin main

# 全てのブランチをプッシュ
git push --all

# 強制プッシュ(危険! 注意)
git push -f origin main
```

### 5. リモートから取得
```bash
# リモートの変更を取得(マージしない)
git fetch origin

# リモートの変更を取得してマージ
git pull origin main

# リベースしながらプル
git pull --rebase origin main
```

---

## 🌿 ブランチ操作

### ブランチの確認・作成・切り替え
```bash
# ブランチ一覧(ローカル)
git branch

# ブランチ一覧(リモート含む)
git branch -a

# 新しいブランチを作成
git branch feature/new-feature

# ブランチを作成して切り替え
git checkout -b feature/new-feature

# ブランチを切り替え
git checkout main

# 新しいコマンド(Git 2.23以降)
git switch main
git switch -c feature/new-feature
```

### ブランチの削除
```bash
# ローカルブランチを削除(マージ済み)
git branch -d feature/old-feature

# ローカルブランチを強制削除
git branch -D feature/old-feature

# リモートブランチを削除
git push origin --delete feature/old-feature
```

### ブランチのマージ
```bash
# mainブランチに戻る
git checkout main

# feature/new-featureをマージ
git merge feature/new-feature

# Fast-forwardしない
git merge --no-ff feature/new-feature

# マージを中止
git merge --abort
```

---

## 🔄 リモートリポジトリ操作

### リモートの確認・追加
```bash
# リモートリポジトリの確認
git remote -v

# リモートを追加
git remote add origin https://github.com/username/repository.git

# リモートのURLを変更
git remote set-url origin https://github.com/username/new-repository.git

# リモートを削除
git remote remove origin
```

### リモートブランチの操作
```bash
# リモートブランチを確認
git branch -r

# リモートの特定ブランチをチェックアウト
git checkout -b feature/remote origin/feature/remote

# ローカルブランチをリモートと紐付け
git branch --set-upstream-to=origin/main main
```

---

## 📜 コミット履歴の確認

### ログの表示
```bash
# コミット履歴を表示
git log

# 1行で表示
git log --oneline

# グラフ表示
git log --graph --oneline --all

# 最新5件を表示
git log -5

# 特定の作者でフィルタ
git log --author="名前"

# 日付でフィルタ
git log --since="2024-01-01" --until="2024-12-31"

# ファイルの変更履歴
git log -p file.txt
```

### コミットの詳細確認
```bash
# 特定のコミットを表示
git show <コミットハッシュ>

# 最新のコミットを表示
git show HEAD

# 1つ前のコミットを表示
git show HEAD~1
```

---

## ⏮️ 変更の取り消し

### 作業ディレクトリの変更を取り消す
```bash
# 特定ファイルの変更を取り消す
git checkout -- file.txt

# 全てのファイルの変更を取り消す
git checkout -- .

# 新しいコマンド
git restore file.txt
git restore .
```

### ステージングを取り消す
```bash
# 特定ファイルをステージングから外す
git reset HEAD file.txt

# 全てのファイルをステージングから外す
git reset HEAD

# 新しいコマンド
git restore --staged file.txt
```

### コミットを取り消す
```bash
# 最新のコミットを取り消す(変更は保持)
git reset --soft HEAD~1

# 最新のコミットを取り消す(ステージングも解除)
git reset HEAD~1

# 最新のコミットを完全に削除(危険!)
git reset --hard HEAD~1

# 特定のコミットまで戻る
git reset --hard <コミットハッシュ>
```

### コミットを打ち消す(安全)
```bash
# 特定のコミットを打ち消す新しいコミットを作成
git revert <コミットハッシュ>

# 最新のコミットを打ち消す
git revert HEAD
```

---

## 🍒 応用コマンド

### チェリーピック
```bash
# 特定のコミットを現在のブランチに適用
git cherry-pick <コミットハッシュ>

# 複数のコミットを適用
git cherry-pick abc123 def456

# 競合時の操作
git cherry-pick --continue  # 解決後
git cherry-pick --abort     # 中止
```

### リベース
```bash
# mainの最新を取り込む
git rebase main

# インタラクティブリベース(コミット整理)
git rebase -i HEAD~3

# リベース中の操作
git rebase --continue  # 競合解決後
git rebase --skip      # スキップ
git rebase --abort     # 中止
```

### スタッシュ(一時保存)
```bash
# 現在の変更を一時保存
git stash

# メッセージ付きで保存
git stash save "作業中の機能"

# スタッシュ一覧
git stash list

# 最新のスタッシュを復元
git stash pop

# 特定のスタッシュを復元
git stash apply stash@{0}

# スタッシュを削除
git stash drop stash@{0}

# 全てのスタッシュを削除
git stash clear
```

### タグ
```bash
# タグ一覧
git tag

# タグを作成
git tag v1.0.0

# 注釈付きタグを作成
git tag -a v1.0.0 -m "バージョン1.0.0"

# タグをプッシュ
git push origin v1.0.0

# 全てのタグをプッシュ
git push --tags

# タグを削除
git tag -d v1.0.0
git push origin :refs/tags/v1.0.0
```

---

## 🔍 便利なコマンド

### 検索
```bash
# コミットメッセージから検索
git log --grep="バグ修正"

# コード内を検索
git grep "function"

# 特定のファイルを含むコミットを検索
git log --all -- path/to/file.txt
```

### 差分確認
```bash
# ブランチ間の差分
git diff main feature/new

# コミット間の差分
git diff abc123 def456

# ファイル名のみ表示
git diff --name-only

# 統計表示
git diff --stat
```

### 作業者の確認
```bash
# ファイルの各行の作者を表示
git blame file.txt

# 特定の行範囲を表示
git blame -L 10,20 file.txt
```

### クリーンアップ
```bash
# 追跡されていないファイルを削除(ドライラン)
git clean -n

# 追跡されていないファイルを削除
git clean -f

# ディレクトリも削除
git clean -fd
```

---

## ⚠️ 競合(コンフリクト)解消

### 競合発生時
```bash
# 1. 競合しているファイルを確認
git status

# 2. ファイルを編集して競合を解消
# <<<<<<< HEAD
# あなたの変更
# =======
# 相手の変更
# >>>>>>> branch-name

# 3. 解決したファイルをadd
git add file.txt

# 4. マージを完了
git commit

# 競合解消のヘルパー
git checkout --ours file.txt    # 自分の変更を採用
git checkout --theirs file.txt  # 相手の変更を採用
```

---

## 🔐 GitHub連携

### SSH鍵の設定
```bash
# SSH鍵を生成
ssh-keygen -t ed25519 -C "your.email@example.com"

# SSH鍵をコピー(Windows)
clip < ~/.ssh/id_ed25519.pub

# GitHub設定 → SSH and GPG keys → New SSH key
```

### Personal Access Token(PAT)
```bash
# GitHubでPATを作成
# Settings → Developer settings → Personal access tokens → Generate new token

# HTTPS接続でPATを使用
git clone https://github.com/username/repository.git
# ユーザー名: username
# パスワード: PAT
```

---

## 🎯 よく使うエイリアス設定

```bash
# 便利なエイリアスを設定
git config --global alias.st status
git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.unstage 'reset HEAD --'
git config --global alias.last 'log -1 HEAD'
git config --global alias.visual 'log --graph --oneline --all'

# 使用例
git st          # git status
git co main     # git checkout main
git visual      # きれいなグラフ表示
```

---

## 📋 .gitignoreファイル

### .gitignoreの例
```bash
# .gitignoreファイルを作成
touch .gitignore
```

```gitignore
# Python
__pycache__/
*.py[cod]
*.so
.Python
venv/
env/

# Node.js
node_modules/
npm-debug.log

# IDE
.vscode/
.idea/
*.swp

# OS
.DS_Store
Thumbs.db

# 環境変数
.env
.env.local

# ビルド成果物
dist/
build/
*.exe
```

---

## 🚨 緊急時のコマンド

### 間違えてコミットした時
```bash
# 最新のコミットを取り消し(変更は保持)
git reset --soft HEAD~1

# コミットメッセージを修正
git commit --amend -m "正しいメッセージ"
```

### 間違えてプッシュした時
```bash
# ローカルで修正してから強制プッシュ(チームと調整!)
git push -f origin main
```

### ファイルを間違えてコミットした時
```bash
# ファイルを削除して再コミット
git rm --cached secret.txt
git commit --amend
```

### ブランチを間違えた時
```bash
# コミットを別ブランチに移動
git checkout correct-branch
git cherry-pick <コミットハッシュ>

# 元のブランチで削除
git checkout wrong-branch
git reset --hard HEAD~1
```

---

## 📚 チーム開発のベストプラクティス

### コミットメッセージの書き方
```bash
# ✅ 良い例
git commit -m "feat: ユーザーログイン機能を追加"
git commit -m "fix: ヘッダーのレイアウト崩れを修正"
git commit -m "docs: READMEにインストール手順を追加"

# ❌ 悪い例
git commit -m "修正"
git commit -m "変更"
git commit -m "あああ"
```

### プルリクエストの流れ
```bash
# 1. 最新のmainを取得
git checkout main
git pull origin main

# 2. 作業ブランチ作成
git checkout -b feature/user-auth

# 3. 作業してコミット
git add .
git commit -m "feat: ユーザー認証を実装"

# 4. プッシュ
git push -u origin feature/user-auth

# 5. GitHubでPull Request作成

# 6. レビュー後マージされたら
git checkout main
git pull origin main
git branch -d feature/user-auth
```

---

## 🆘 トラブルシューティング

### よくあるエラーと対処法

#### エラー: `fatal: not a git repository`
```bash
# 対処: Gitリポジトリを初期化
git init
```

#### エラー: `Permission denied (publickey)`
```bash
# 対処: SSH鍵を設定
ssh-keygen -t ed25519 -C "your.email@example.com"
# 公開鍵をGitHubに登録
```

#### エラー: `Your branch is behind`
```bash
# 対処: リモートの変更を取り込む
git pull origin main
```

#### エラー: `refusing to merge unrelated histories`
```bash
# 対処: 強制的にマージを許可
git pull origin main --allow-unrelated-histories
```

---

## 🎓 学習リソース

- **公式ドキュメント**: https://git-scm.com/doc
- **GitHub Docs**: https://docs.github.com
- **練習サイト**: https://learngitbranching.js.org/

---

**💡 TIP**: このチートシートを印刷するか、ブックマークしていつでも参照できるようにしましょう!

<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Git ブランチ・リポジトリ 図解ガイド</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .section {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }
        
        h3 {
            color: #764ba2;
            margin: 20px 0 10px;
            font-size: 1.3em;
        }
        
        .diagram {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            margin: 20px 0;
            border: 2px solid #e0e0e0;
            position: relative;
        }
        
        .repo-box {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.3);
        }
        
        .local-repo {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }
        
        .github-repo {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        }
        
        .branch {
            display: inline-block;
            padding: 8px 15px;
            margin: 5px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9em;
        }
        
        .branch-main {
            background: #ef4444;
            color: white;
        }
        
        .branch-develop {
            background: #3b82f6;
            color: white;
        }
        
        .branch-feature {
            background: #10b981;
            color: white;
        }
        
        .branch-hotfix {
            background: #f97316;
            color: white;
        }
        
        .branch-bugfix {
            background: #8b5cf6;
            color: white;
        }
        
        .flow-diagram {
            display: flex;
            align-items: center;
            justify-content: space-around;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .flow-box {
            background: white;
            border: 3px solid #667eea;
            border-radius: 10px;
            padding: 15px 25px;
            margin: 10px;
            min-width: 150px;
            text-align: center;
            font-weight: bold;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }
        
        .arrow {
            font-size: 2em;
            color: #667eea;
            margin: 0 10px;
        }
        
        .commit-graph {
            font-family: 'Courier New', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 10px;
            overflow-x: auto;
            line-height: 1.6;
            margin: 15px 0;
        }
        
        .commit {
            color: #4ec9b0;
        }
        
        .branch-label {
            color: #ce9178;
            font-weight: bold;
        }
        
        .code-box {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }
        
        .code-comment {
            color: #75715e;
        }
        
        .highlight {
            background: #fff3cd;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            color: #856404;
        }
        
        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        
        .warning-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        
        .success-box {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .tab-button {
            padding: 12px 25px;
            background: #e0e0e0;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .tab-button.active {
            background: #667eea;
            color: white;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }

        @media (max-width: 768px) {
            .flow-diagram {
                flex-direction: column;
            }
            .arrow {
                transform: rotate(90deg);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🌿 Git ブランチ・リポジトリ 図解ガイド</h1>
        
        <!-- セクション1: リポジトリとは -->
        <div class="section">
            <h2>📦 1. リポジトリとは?</h2>
            
            <div class="info-box">
                <strong>リポジトリ = プロジェクトの保管庫</strong><br>
                ファイルの変更履歴を全て記録する「タイムマシン付きフォルダ」のようなもの
            </div>
            
            <div class="diagram



作成しました — チームシートをキャンバスに置きました。
内容を確認して、次のどれをしたいか教えてください（遠慮なく複数選択可）：

* 文言のトーンをもっと「カジュアル／フォーマル」に変える
* Qiita 用のフォーマット（タグや見出しの細かい調整）に整形する
* Windows / macOS / VSCode 向けの具体的な手順を追加する
* `reflog` を使った復旧手順など、トラブルシュート章を詳しく追加する
* サンプル演習（手を動かす練習問題）を作る

どれを追加するか言ってくれれば、すぐに追記します！

応用編セクションを追加しました。`add`取り消しや`rebase`・`tag`の実践的操作など、もう少し具体例（コマンドやケース別手順）も追記しますか？

ーーーー
了解しました！💡
では次は、**Git応用編：実践でエラーが発生したときの対処法** をステップ形式でまとめます。
チーム開発で新人エンジニアがつまづきやすい「実際に起きるエラー」と「解決ステップ」を中心にします。

---

# 🧭 Git応用編：実践でエラー発生したときの対処法

---

## 🎯 目的

実務では、**コミットやプッシュができない／リベースでコンフリクトした／間違って上書きした**
といったエラーが頻発します。
ここでは、チーム開発でよくあるトラブルを実例付きで整理します。

---

## 💥 ケース①：`git add` しすぎた（不要なファイルを追加）

### 🔍 状況

間違って `.env` や `__pycache__` などを `add` してしまった。

### ✅ 解決ステップ

```bash
# ステージから削除（コミット前）
git reset HEAD <ファイル名>

# すべてリセットしたい場合
git reset HEAD .
```

> 💡「git reset」は“ステージング解除”。作業ツリーの変更自体は残ります。
> `.gitignore` に登録して、再発防止を！

---

## 💣 ケース②：コミットを間違えた

### ✅ 解決ステップ

```bash
# 直前のコミットメッセージ修正
git commit --amend

# 完全に取り消したい場合
git reset --soft HEAD~1
```

> ⚠️ すでにリモートにプッシュした後は、`--amend`や`reset`を使うと履歴がずれるため注意！
> → 修正版を新しくコミットしてプッシュする方が安全です。

---

## ⚔ ケース③：`git rebase` でコンフリクト発生

### 🔍 状況

ブランチ整理中にコンフリクトが出た。

### ✅ 解決ステップ

```bash
# コンフリクト箇所をエディタで修正後
git add <修正したファイル>

# リベースを再開
git rebase --continue

# 中断したい場合
git rebase --abort
```

> 💡 コンフリクト解消のポイント
>
> * `<<<<<<<`, `=======`, `>>>>>>>` を探す
> * どちらの変更を採用するか確認（場合によっては両方）
> * 修正後は `--continue`

---

## 🌀 ケース④：リモートにプッシュできない

### 🔍 原因

* 他の人が先にプッシュして履歴がズレている
* `rebase`後にpushしたときの「非fast-forward」エラー

### ✅ 解決ステップ

```bash
# 最新を取り込み
git pull --rebase origin <ブランチ名>

# その後、再度プッシュ
git push origin <ブランチ名>
```

> 💡 「--rebase」を付けると、履歴をきれいに保ったまま更新できます。

---

## 🧨 ケース⑤：`git revert`で取り消したい

### 🔍 状況

特定のコミットだけ取り消したい（他の変更は残す）

### ✅ 解決ステップ

```bash
# コミットを1つ取り消す
git revert <コミットID>

# 取り消しを複数まとめる
git revert <開始ID>^..<終了ID>
```

> 💡 `revert`は履歴を壊さず安全。チーム開発では`reset`より推奨されます。

---

## 🏷 ケース⑥：`tag`を打ち間違えた

### ✅ 解決ステップ

```bash
# タグ一覧表示
git tag

# タグ削除
git tag -d <タグ名>

# リモートからも削除
git push origin :refs/tags/<タグ名>

# 正しいタグを再作成
git tag -a v1.0.1 -m "修正版リリース"
git push origin v1.0.1
```

---

## 💡 チーム開発Tips

| 状況             | 安全な対応                                 |
| -------------- | ------------------------------------- |
| コミットやpushを間違えた | `revert`を使う（履歴を壊さない）                  |
| 履歴を整理したい       | 個人ブランチで`rebase`、チームブランチでは`merge`      |
| コミットメッセージを整える  | `git log --oneline`で履歴を見直し            |
| コードレビューを受けた    | 修正コミット後、`push --force-with-lease`で上書き |

---

## 🚀 まとめ

| コマンド     | 目的             | よくある失敗      |
| -------- | -------------- | ----------- |
| `reset`  | ステージ解除 or 履歴戻し | 間違って履歴消去    |
| `revert` | コミット取り消し（安全）   | 対象コミットを間違える |
| `rebase` | 履歴整理・最新統合      | コンフリクト放置    |
| `tag`    | バージョン管理        | タグ名重複・削除忘れ  |

---

もしよければ、
次は「💻実際のコンフリクト発生例＋解決までの手順（画面付きシナリオ）」を追加できます。
たとえば「2人のエンジニアが同じ行を編集→リベースで衝突→修正→成功」など。

👉追加しますか？

ーーーー
最高のテーマ選びです👏✨
このシナリオは **チーム開発で全員が一度は経験する超定番トラブル**。
実際の流れを「Aさん」「Bさん」の2人が作業する形で、**衝突→解決→成功まで** をリアルに追体験できるようにまとめました。

---

# 💥 実践シナリオ：同じ行を編集してリベースで衝突 → 解決まで

---

## 🎯 想定シナリオ

2人のエンジニア **Aさん** と **Bさん** が、
同じファイル `app.py` の同じ行を**同時に変更**してしまい、
後からリベースをしたAさんが**コンフリクトに直面**するケースです。

---

## 👩‍💻 ステップ1：共通の初期状態

まず、2人とも同じ `main` ブランチから作業を始めます。

```bash
git clone https://github.com/team/sample-project.git
cd sample-project
git checkout -b feature-A
```

`app.py` の内容：

```python
def greeting():
    print("Hello World")
```

---

## 👨‍💻 ステップ2：Aさんの変更（feature-Aブランチ）

Aさんは文言を変更してコミットします。

```python
def greeting():
    print("Hello from A")
```

```bash
git add app.py
git commit -m "A: change greeting message"
```

---

## 👩‍💻 ステップ3：Bさんの変更（feature-Bブランチ）

Bさんも同じ行を別の文言にしてコミットします。

```python
def greeting():
    print("Hello from B")
```

```bash
git add app.py
git commit -m "B: update greeting message"
```

---

## ⚙ ステップ4：Bさんが先に`main`へマージ

Bさんの変更が先にレビュー＆マージされました。

```bash
git checkout main
git merge feature-B
git push origin main
```

---

## 💣 ステップ5：Aさんが`main`を取り込もうとしてリベース

Aさんがリモートの更新を取り込もうとしてリベースします。

```bash
git checkout feature-A
git fetch origin
git rebase origin/main
```

すると、エラー発生👇

```
Auto-merging app.py
CONFLICT (content): Merge conflict in app.py
error: could not apply A: change greeting message
```

---

## ⚠ ステップ6：コンフリクト発生箇所を確認

`app.py`を開くと、以下のようになっています：

```python
def greeting():
<<<<<<< HEAD
    print("Hello from B")
=======
    print("Hello from A")
>>>>>>> A: change greeting message
```

---

## 🧩 ステップ7：衝突を手動で解決

チームで話し合い、「両方のメッセージを残す」ことに決定。
ファイルを以下のように修正します。

```python
def greeting():
    print("Hello from A and B")
```

修正したら：

```bash
git add app.py
git rebase --continue
```

---

## ✅ ステップ8：リベース成功！

リベース完了メッセージが出たらOKです。

```
Successfully rebased and updated refs/heads/feature-A.
```

---

## 🚀 ステップ9：リモートに反映

```bash
git push origin feature-A
```

もし一度リベース済みのブランチを既にプッシュしていた場合は：

```bash
git push origin feature-A --force-with-lease
```

> 💡 `--force-with-lease` は「他人の変更を誤って消さない安全な強制プッシュ」
> 単なる `--force` より推奨されます。

---

## 🧭 まとめ：リベース時のコンフリクト対処フロー

| 手順 | コマンド                     | 意味                 |
| -- | ------------------------ | ------------------ |
| 1  | `git rebase origin/main` | 最新ブランチに自分の変更を並べ替える |
| 2  | ファイルに `<<<<<<<` が出たら修正   | 衝突箇所を手動で解決         |
| 3  | `git add <修正ファイル>`       | 解決済みとしてマーク         |
| 4  | `git rebase --continue`  | 残りのリベースを再開         |
| 5  | `git rebase --abort`     | やり直したい時にリセット       |

---

## 💡 チーム開発でのポイント

| 状況             | ベストプラクティス               |
| -------------- | ----------------------- |
| 同じファイルを編集しそうな時 | 事前に声かけ or Issueで明示      |
| リベース中に不安な時     | `git status`で進行状況確認     |
| 修正後の動作確認       | ローカルで動作テスト後にpush        |
| 履歴を整えたい時       | `git rebase -i` でコミット整理 |

---

## 🧠 補足：GUIでの解決も可能

VSCodeやGitKrakenなどでは、
コンフリクト箇所が色分け表示され、
「A側を採用」「B側を採用」「両方採用」ボタンで解決できます。

---

このように、**リベースでの衝突は“日常的”**ですが、
流れを理解すれば冷静に対応できます。
慣れてくると「リベース＝履歴を美しく保つ味方✨」になります。

---

次に進めるなら、こんな展開ができます👇

* 🧱 **リベース vs マージの使い分け解説**（履歴がどう変わるか図解）
* 🧭 **リベース中に発生する他のエラーまとめ（e.g., stopped at pick, unmerged paths）**

どちらを続きに書きましょうか？
ーーー
すばらしい方向転換です👏✨
ここからは **PyCharmを使わず、コマンドラインで「A側を採用」「B側を採用」「両方採用」する方法** を、
実践的に・順を追って説明します。
（VSCodeを使わなくても、Gitだけで完全に解決できます💪）

---

# 🧭 Gitコマンドでのコンフリクト解消：「A側」「B側」「両方採用」

---

## 🎯 前提：コンフリクト発生の状態

例として、`app.py` に同じ行を2人が変更し、
Aさんがリベース時にコンフリクトが発生した状態：

```bash
git rebase origin/main
```

すると以下のようなエラーが出ます👇

```
Auto-merging app.py
CONFLICT (content): Merge conflict in app.py
error: could not apply A: change greeting message
```

---

## ⚙ ステップ1：状況確認

まず、どのファイルで衝突しているか確認します。

```bash
git status
```

出力例：

```
rebase in progress; onto abc1234
You are currently rebasing branch 'feature-A' on 'abc1234'.
Unmerged paths:
  (use "git add <file>..." to mark resolution)
    both modified:   app.py
```

👉 `both modified` と出ているのが衝突ファイル。

---

## 🧩 ステップ2：ファイル内容を確認

```bash
cat app.py
```

中身はこうなっています：

```python
def greeting():
<<<<<<< HEAD
    print("Hello from B")
=======
    print("Hello from A")
>>>>>>> feature-A
```

---

## 🅰️ 「A側を採用」：自分（現在のブランチ）の変更を残す

自分の変更（`feature-A`の方）を残したい場合は：

```bash
git checkout --ours app.py
```

> 🧠 `--ours` は「今いるブランチ（自分側）」を意味します。

確認：

```bash
cat app.py
```

結果：

```python
def greeting():
    print("Hello from B")
```

変更を確定：

```bash
git add app.py
git rebase --continue
```

---

## 🅱️ 「B側を採用」：相手（取り込み先）の変更を残す

相手の変更（`main`や`feature-B`側）を残したい場合は：

```bash
git checkout --theirs app.py
```

> 💡 `--theirs` は「取り込もうとしているブランチ（相手側）」を意味します。

確認：

```bash
cat app.py
```

結果：

```python
def greeting():
    print("Hello from A")
```

その後：

```bash
git add app.py
git rebase --continue
```

---

## 🤝 「両方採用」：どちらの変更も残す

両方を残したい場合は、手動で編集します👇

```bash
nano app.py
```

内容を次のように書き換えます：

```python
def greeting():
    print("Hello from B")
    print("Hello from A")
```

保存して閉じたら：

```bash
git add app.py
git rebase --continue
```

---

## 🧠 ステップ3：確認

リベースが正常に続行されれば成功です。

```
Successfully rebased and updated refs/heads/feature-A.
```

完了後、履歴を確認：

```bash
git log --oneline --graph
```

---

## 💡 まとめ：A側／B側を採用するコマンド早見表

| 目的              | コマンド                           | 意味            |
| --------------- | ------------------------------ | ------------- |
| A側を採用（自分の変更を残す） | `git checkout --ours <file>`   | 自分の変更を優先      |
| B側を採用（相手の変更を残す） | `git checkout --theirs <file>` | 相手の変更を優先      |
| 両方採用（統合）        | 手動で編集後に `git add <file>`       | 両方を残す         |
| 解決済みにする         | `git add <file>`               | 衝突が解決した印をつける  |
| リベース続行          | `git rebase --continue`        | 次のコミットへ進む     |
| やり直し            | `git rebase --abort`           | リベースを中止して元に戻す |

---

## 🧭 実務でのコツ

| 状況          | 推奨操作                                               |
| ----------- | -------------------------------------------------- |
| 変更内容が重複     | どちらかを採用（`--ours` / `--theirs`）                     |
| 両方必要        | 手動編集（`nano`, `vim`, またはVSCodeで開く）                  |
| コンフリクトが多すぎる | 一度 `git rebase --abort` で中止し、`git merge` に切り替えるのも可 |
| 不安な時        | まず `git diff` で差分を確認してから採用コマンドを実行                  |

---

## ✅ 補足：GUIと組み合わせる裏技

PyCharmやVSCodeがインストールされていれば、
CLIからGUIマージツールを呼び出すこともできます👇

```bash
git mergetool
```

> 自動でPyCharmのマージ画面が開き、視覚的に選択できます。

---

この流れを実践シートとして載せるなら、
タイトル例：
**「Gitリベース衝突の実践コマンド操作シート（A/B両方採用編）」**
としてまとめるのがおすすめです。

---

続けて以下のどちらを追加しましょうか？👇
1️⃣ `rebase --abort` や `rebase --skip` の緊急リカバリー編
2️⃣ コンフリクトをテストで検出する自動化Tips（CI/CD編）
ーーー
新人エンジニア向けに、PyCharmでのリベース衝突から解決・成功までの実践例を追記しました。
もう少し掘り下げて、**「rebaseとmergeの比較」図解** や **「pull時に自動rebaseを有効にする設定」** も追加しましょうか？


ーーー
リベース中の緊急リカバリー（`--abort`・`--skip`）と、CI/CDでの自動コンフリクト検出Tipsを追加しました。
次は、**GitHub Actionsで実際に通知（Slack・メール）を送る設定例**も追記しましょうか？

ーーーー
もちろんです！😊
先ほどの「ふわふわ大福店の税込み計算プログラム」の **docstring（ドキュメント文字列）** を「5段文章法」風に大きく解説してみます。

---

## 🍡 1. 起（き）〜docstringって何？〜

プログラムを書いていると、「この関数は何をするのか？」「引数は何？」「戻り値は？」と迷うことがあります。
そのとき役立つのが **docstring（ドキュメント文字列）** です。
docstringは **関数やクラスの最初に書く説明文** で、Pythonでは `"""説明"""` の形で書きます。

---

## 2. 承（しょう）〜docstringの役割〜

docstringのメリットは大きく3つです：

1. **誰が見ても関数の役割がわかる**
2. **引数や戻り値の意味を明確にできる**
3. **後で `help()` を使うと自動で説明が出る**

例えば、先ほどの関数にdocstringをつけるとこうなります：

```python
def calculate_total(price: int) -> int:
    """税込み金額を計算する関数

    Args:
        price (int): 大福1個の税抜き価格

    Returns:
        int: 税込み合計金額
    """
    total = int(price * (1 + TAX_RATE))
    return total
```

---

## 3. 転（てん）〜docstringの書き方ポイント〜

docstringを書くときは次のポイントを意識します：

* **関数の目的** を最初に1行で書く
* **引数** を `Args:` で書く
* **戻り値** を `Returns:` で書く
* 必要に応じて **例外や補足** も書く

これだけで、他の人や未来の自分がすぐ理解できます。

---

## 4. 結（けつ）〜実際の活用例〜

例えば、Pythonの `help()` を使うと、docstringが自動で出力されます：

```python
help(calculate_total)
```

出力例：

```
Help on function calculate_total in module __main__:

calculate_total(price: int) -> int
    税込み金額を計算する関数

    Args:
        price (int): 大福1個の税抜き価格

    Returns:
        int: 税込み合計金額
```

これで、関数の意味や使い方が一目でわかります。

---

## 5. まとめ（ふりかえり）

* docstringは **関数の説明文**
* Pythonでは `"""説明"""` で書く
* `Args:` や `Returns:` を使うとより親切
* `help()` で自動表示されるので、**自分も他人も迷わないコード** になる

---

💡 ポイント：新人エンジニアでも **docstringを書くだけで「親切なコード」になる** ので、習慣にするととても便利です。

---

もしよければ、このdocstringをさらに **「複数個の大福購入」対応版」** に書き換えた例も作れます。
作ってほしいですか？
ーーーー










目次
🐰 Pythonクラスと継承の基本文法についてざっくり備忘録
① 親子クラス（単一継承）
② 階層継承（親→子→孫）
③ 多重継承（複数の親を持つ）
④ __init__（初期化）
⑤ super()（親の処理を呼ぶ）
⑥ コンストラクタ
⑦ 特殊メソッド（マジックメソッド）
⑧ クラス変数（全員で共有）
⑨ インスタンス変数（個別の値）
⑩ メソッド（クラスの中の関数）
⑪ self
⑫ *args, **kwargs（可変長引数）
🐰 Pythonクラスと継承（GoogleスタイルDocstring版）のソースコード例
1️⃣ *args：位置引数をタプルで受け取る
ポイント
例
2️⃣ **kwargs：キーワード引数を辞書で受け取る
ポイント
例
3️⃣ *args と **kwargs を同時に使う
4️⃣ 実務でのよくある使い方
例1：柔軟なメソッド
出力
1️⃣ super() の基本
ポイント
2️⃣ 単純な例（親クラスのメソッドを呼ぶ）
3️⃣ __init__ でのよくある使い方
4️⃣ 多重継承でも安心
5️⃣ 実務での便利な例（柔軟な継承）
1️⃣ 基本的なオーバーライド
2️⃣ オーバーライド＋親メソッド呼び出し
3️⃣ 実務っぽい例（ふわふわ大福店🍡）
1️⃣ 基本イメージ
2️⃣ クラス内で使う例（ふわふわ大福店🍡）
3️⃣ 継承と組み合わせる例
🧩 特殊メソッドとは？
① __init__（初期化）
② __str__（文字列化）
③ __len__（長さ）
④ __add__（+演算子のカスタマイズ）
⑤ __eq__（==のカスタマイズ）
🧾 まとめ表
🧩 1. コンストラクタとは？
🍡 2. 基本の書き方
🍰 3. 複数の引数をとる
🏪 4. 初期値（デフォルト値）を設定
🧠 5. super() と一緒に使う（親クラスの初期化）
🧾 6. まとめ表
🎓 7. 実務的イメージ（まとめ）
🍵 デストラクタ（__del__）とは？
🍡 1. 基本の使い方
🏪 2. 自動で呼ばれるタイミング
🧠 3. 注意点（デストラクタの落とし穴）
🧾 4. コンストラクタとデストラクタのペア
💡 まとめ表
🎓 5. まとめコメント
🍰 __add__とは？
🍡 例①：基本的な使い方
🍵 例②：数値を扱うクラスでも使える！
🍬 例③：他の型（intなど）もOKにするには？
🎓 例④：逆方向の加算（__radd__）
🧾 まとめ表
 まとめ
🥇 ① __sub__（マイナスのオーバーロード）
🍡 例：Price クラスで差をとる
🍵 intにも対応する例：
🥈 ② __eq__（== のオーバーロード）
🍰 例：同じ値段なら同じとみなす
🥉 ③ __repr__ / __str__（表示の違い）
🍵 例：違いを体験しよう
🎓 まとめ表
 まとめコメント
ポイントのまとめ表
その他押さえておきたい文法の概要
https://github.com/Forbusinessuseyukikoishiguro/Python-20251004-Selenium-/tree/main
選択中 30 / 21,258 文字

閉じる


キャンセル

公開に進む

🐰 Pythonクラスと継承の基本文法備忘録まとめ　オブジェクト指向新人エンジニア向け　＃ソースコードあり
テキスト未選択のときにタブキーでメニューボタンへ移動できます


🐰 Pythonクラスと継承の基本文法についてざっくり備忘録
ここでは、ふわふわ大福店🍡シリーズ の例で、
①〜⑫を順に・かんたんコード＋やさしい解説で紹介します。


目次
🐰 Pythonクラスと継承の基本文法についてざっくり備忘録
① 親子クラス（単一継承）
② 階層継承（親→子→孫）
③ 多重継承（複数の親を持つ）
④ __init__（初期化）
⑤ super()（親の処理を呼ぶ）
⑥ コンストラクタ
⑦ 特殊メソッド（マジックメソッド）
⑧ クラス変数（全員で共有）
⑨ インスタンス変数（個別の値）
⑩ メソッド（クラスの中の関数）
⑪ self
⑫ *args, **kwargs（可変長引数）
🐰 Pythonクラスと継承（GoogleスタイルDocstring版）のソースコード例
1️⃣ *args：位置引数をタプルで受け取る
ポイント
例
2️⃣ **kwargs：キーワード引数を辞書で受け取る
ポイント
例
3️⃣ *args と **kwargs を同時に使う
4️⃣ 実務でのよくある使い方
例1：柔軟なメソッド
出力
1️⃣ super() の基本
ポイント
2️⃣ 単純な例（親クラスのメソッドを呼ぶ）
3️⃣ __init__ でのよくある使い方
4️⃣ 多重継承でも安心
5️⃣ 実務での便利な例（柔軟な継承）
1️⃣ 基本的なオーバーライド
2️⃣ オーバーライド＋親メソッド呼び出し
3️⃣ 実務っぽい例（ふわふわ大福店🍡）
1️⃣ 基本イメージ
2️⃣ クラス内で使う例（ふわふわ大福店🍡）
3️⃣ 継承と組み合わせる例
🧩 特殊メソッドとは？
① __init__（初期化）
② __str__（文字列化）
③ __len__（長さ）
④ __add__（+演算子のカスタマイズ）
⑤ __eq__（==のカスタマイズ）
🧾 まとめ表
🧩 1. コンストラクタとは？
🍡 2. 基本の書き方
🍰 3. 複数の引数をとる
🏪 4. 初期値（デフォルト値）を設定
🧠 5. super() と一緒に使う（親クラスの初期化）
🧾 6. まとめ表
🎓 7. 実務的イメージ（まとめ）
🍵 デストラクタ（__del__）とは？
🍡 1. 基本の使い方
🏪 2. 自動で呼ばれるタイミング
🧠 3. 注意点（デストラクタの落とし穴）
🧾 4. コンストラクタとデストラクタのペア
💡 まとめ表
🎓 5. まとめコメント
🍰 __add__とは？
🍡 例①：基本的な使い方
🍵 例②：数値を扱うクラスでも使える！
🍬 例③：他の型（intなど）もOKにするには？
🎓 例④：逆方向の加算（__radd__）
🧾 まとめ表
 まとめ
🥇 ① __sub__（マイナスのオーバーロード）
🍡 例：Price クラスで差をとる
🍵 intにも対応する例：
🥈 ② __eq__（== のオーバーロード）
🍰 例：同じ値段なら同じとみなす
🥉 ③ __repr__ / __str__（表示の違い）
🍵 例：違いを体験しよう
🎓 まとめ表
 まとめコメント
ポイントのまとめ表
その他押さえておきたい文法の概要
https://github.com/Forbusinessuseyukikoishiguro/Python-20251004-Selenium-/tree/main
① 親子クラス（単一継承）
class Parent:
    def greet(self):
        print("こんにちは！私は親クラスです。")

class Child(Parent):
    def greet_child(self):
        print("私は子クラスです！")

c = Child()
c.greet()        # 親のメソッド
c.greet_child()  # 子のメソッド

💡 解説:
Child(Parent) のように書くと、Parent の機能を引き継げます。

② 階層継承（親→子→孫）
class GrandParent:
    def say(self):
        print("祖父母クラスです。")

class Parent(GrandParent):
    def say_parent(self):
        print("親クラスです。")

class Child(Parent):
    def say_child(self):
        print("子クラスです。")

c = Child()
c.say()         # 祖父母クラス
c.say_parent()  # 親クラス
c.say_child()   # 子クラス

💡 解説:
3段階の継承も可能。
上位クラス（祖父母）までメソッドを引き継げます。

③ 多重継承（複数の親を持つ）
class A:
    def hello(self):
        print("Aクラスからこんにちは")

class B:
    def hello(self):
        print("Bクラスからこんにちは")

class C(A, B):
    pass

c = C()
c.hello()  # ⚠️ Aが優先される（左から順）

💡 解説:
複数クラスを (A, B) のように継承できます。
順番（MRO: Method Resolution Order） に注意。

④ __init__（初期化）
class Shop:
    def __init__(self, name):
        self.name = name  # 初期値設定
        print(f"{self.name}を開店しました！")

shop = Shop("ふわふわ大福店")

💡 解説:
__init__ は コンストラクタ。
インスタンスを作るときに自動で呼ばれます。

⑤ super()（親の処理を呼ぶ）
class Parent:
    def __init__(self):
        print("親クラスの初期化")

class Child(Parent):
    def __init__(self):
        super().__init__()  # 親の初期化を呼び出す
        print("子クラスの初期化")

c = Child()

💡 解説:
super() は 親クラスのメソッドを呼ぶ ための関数。
多重継承でも安全に処理できます。

⑥ コンストラクタ
上の __init__ と同じ意味です。
つまり：

「インスタンスが作られるときに自動実行されるメソッド」


⑦ 特殊メソッド（マジックメソッド）
class Daifuku:
    def __init__(self, flavor):
        self.flavor = flavor

    def __str__(self):
        return f"🍡 {self.flavor}大福です"

d = Daifuku("あんこ")
print(d)  # 🍡 あんこ大福です

💡 解説:
__str__, __len__, __add__ など、
__〇〇__ で囲まれたメソッドは Pythonの特別ルール です。

⑧ クラス変数（全員で共有）
class Shop:
    tax_rate = 0.1  # クラス変数（共通）

    def __init__(self, name):
        self.name = name

print(Shop.tax_rate)

💡 解説:
全インスタンスで共通の値。
Shop.tax_rate のように参照します。

⑨ インスタンス変数（個別の値）
class Shop:
    def __init__(self, name):
        self.name = name  # インスタンス変数（個別）

s1 = Shop("もちもち店")
s2 = Shop("ぴょんぴょん店")

print(s1.name, s2.name)

💡 解説:
各インスタンスごとに異なるデータを持てます。

⑩ メソッド（クラスの中の関数）
class Shop:
    def sell(self, num):
        print(f"🍡 {num}個販売しました！")

s = Shop()
s.sell(5)

💡 解説:
def をクラス内に書くと メソッド（＝クラス専用の関数）になります。

⑪ self
class Shop:
    def __init__(self, name):
        self.name = name

    def greet(self):
        print(f"{self.name}へようこそ！")

s = Shop("ふわふわ大福店")
s.greet()

💡 解説:
self は「自分自身（インスタンス）」を指します。
インスタンス変数にアクセスするための“鍵”のようなものです。

⑫ *args, **kwargs（可変長引数）
class Menu:
    def show_items(self, *args, **kwargs):
        print("商品リスト:", args)
        print("価格表:", kwargs)

m = Menu()
m.show_items("あんこ", "いちご", "クリーム", あんこ=150, いちご=200)

💡 解説:

*args: 位置引数のタプル

**kwargs: 名前付き引数の辞書
柔軟に関数やメソッドの引数を受け取れます。

なるほど、とても良い流れです🌸
では、まず GoogleスタイルDocstring付きで、実際に動くコード をシンプルにまとめたバージョンを作りましょう。
各クラスとメソッドに丁寧なコメントもつけて、新人エンジニアが理解しやすいようにしています。

🐰 Pythonクラスと継承（GoogleスタイルDocstring版）のソースコード例
# ====================================
# ふわふわ大福店シリーズ：クラスと継承の例
# GoogleスタイルDocstring付き
# ====================================

# ① 親子クラス（単一継承）
class Parent:
    """親クラスの例"""
    def greet(self):
        """親クラスの挨拶メソッド"""
        print("こんにちは！私は親クラスです。")

class Child(Parent):
    """親クラスを継承した子クラス"""
    def greet_child(self):
        """子クラス専用の挨拶"""
        print("私は子クラスです！")

# テスト
c = Child()
c.greet()        # 親のメソッド
c.greet_child()  # 子のメソッド


# ② 階層継承（親→子→孫）
class GrandParent:
    """祖父母クラス"""
    def say(self):
        """祖父母の挨拶"""
        print("祖父母クラスです。")

class Parent2(GrandParent):
    """親クラス"""
    def say_parent(self):
        print("親クラスです。")

class Child2(Parent2):
    """子クラス"""
    def say_child(self):
        print("子クラスです。")

# テスト
c2 = Child2()
c2.say()
c2.say_parent()
c2.say_child()


# ③ 多重継承（複数の親を持つ）
class A:
    def hello(self):
        print("Aクラスからこんにちは")

class B:
    def hello(self):
        print("Bクラスからこんにちは")

class C(A, B):
    """AとBを継承（左側優先）"""
    pass

c3 = C()
c3.hello()  # Aが優先される


# ④ __init__（初期化）
class Shop:
    """お店クラスの例"""
    def __init__(self, name):
        """
        インスタンス生成時に名前を初期化

        Args:
            name (str): お店の名前
        """
        self.name = name
        print(f"{self.name}を開店しました！")

shop = Shop("ふわふわ大福店")


# ⑤ super()（親の処理を呼ぶ）
class ParentInit:
    """親クラスの初期化"""
    def __init__(self):
        print("親クラスの初期化")

class ChildInit(ParentInit):
    """子クラスの初期化"""
    def __init__(self):
        super().__init__()  # 親の初期化を呼ぶ
        print("子クラスの初期化")

c_init = ChildInit()


# ⑦ 特殊メソッド
class Daifuku:
    """大福クラス"""
    def __init__(self, flavor):
        """
        Args:
            flavor (str): 大福の味
        """
        self.flavor = flavor

    def __str__(self):
        """文字列表示"""
        return f"🍡 {self.flavor}大福です"

d = Daifuku("あんこ")
print(d)


# ⑧ クラス変数と⑨ インスタンス変数
class Shop2:
    tax_rate = 0.1  # クラス変数（全員で共有）

    def __init__(self, name):
        self.name = name  # インスタンス変数（個別）

s1 = Shop2("もちもち店")
s2 = Shop2("ぴょんぴょん店")
print(f"{s1.name}の税率: {s1.tax_rate}, {s2.name}の税率: {s2.tax_rate}")


# ⑩ メソッド
class Shop3:
    """販売メソッド"""
    def sell(self, num):
        """
        商品を販売する

        Args:
            num (int): 販売する個数
        """
        print(f"🍡 {num}個販売しました！")

s3 = Shop3()
s3.sell(5)


# ⑪ self
class Shop4:
    """selfの例"""
    def __init__(self, name):
        self.name = name

    def greet(self):
        """インスタンス変数を使った挨拶"""
        print(f"{self.name}へようこそ！")

s4 = Shop4("ふわふわ大福店")
s4.greet()


# ⑫ *args, **kwargs（可変長引数）
class Menu:
    """メニュークラス"""
    def show_items(self, *args, **kwargs):
        """
        可変長引数の例

        Args:
            *args: 商品名のタプル
            **kwargs: 商品と価格の辞書
        """
        print("商品リスト:", args)
        print("価格表:", kwargs)

m = Menu()
m.show_items("あんこ", "いちご", "クリーム", あんこ=150, いちご=200)

もちろんです！🌸
*args と **kwargs は Python で 可変長引数 を扱うための仕組みで、少し理解するととても便利です。
順番に丁寧に説明しますね。

1️⃣ *args：位置引数をタプルで受け取る
ポイント
引数の数が 決まっていない場合 に使う

関数の中では タプル になる

名前は args でなくてもよいけど、慣習的に *args と書く

例
def greet_people(*args):
    """何人でも挨拶できる"""
    for name in args:
        print(f"こんにちは、{name}さん！")

greet_people("ゆきこ", "たろう", "はな")

出力:

こんにちは、ゆきこさん！
こんにちは、たろうさん！
こんにちは、はなさん！

💡 解説:

*args に渡された "ゆきこ", "たろう", "はな" は タプル になります。

ループで順番に取り出して処理できます。

2️⃣ **kwargs：キーワード引数を辞書で受け取る
ポイント
名前付き引数の数が 決まっていない場合 に使う

関数の中では 辞書 になる

キーが引数名、値が渡された値

例
def greet_people_with_titles(**kwargs):
    """名前とタイトルで挨拶"""
    for name, title in kwargs.items():
        print(f"こんにちは、{title} {name}さん！")

greet_people_with_titles(yukiko="さん", taro="君", hana="ちゃん")

出力:

こんにちは、さん yukikoさん！
こんにちは、君 taroさん！
こんにちは、ちゃん hanaさん！

💡 解説:

**kwargs に渡された yukiko="さん", taro="君", hana="ちゃん" は 辞書 になります。

.items() で (キー, 値) の形で取り出して処理できます。

3️⃣ *args と **kwargs を同時に使う
def greet_all(*args, **kwargs):
    """位置引数と名前付き引数を両方受け取る"""
    for name in args:
        print(f"こんにちは、{name}さん！")
    for name, title in kwargs.items():
        print(f"こんにちは、{title} {name}さん！")

greet_all("ゆきこ", "たろう", hana="ちゃん", jiro="君")

出力:

こんにちは、ゆきこさん！
こんにちは、たろうさん！
こんにちは、ちゃん hanaさん！
こんにちは、君 jiroさん！

💡 解説:

*args は先に来る（位置引数をまとめる）

**kwargs はその後（名前付き引数をまとめる）

この順番は 必ず守る

4️⃣ 実務でのよくある使い方
例1：柔軟なメソッド
class Menu:
    def show_items(self, *args, **kwargs):
        print("商品リスト:", args)
        print("価格表:", kwargs)

m = Menu()
m.show_items("あんこ", "いちご", あんこ=150, いちご=200)

出力
商品リスト: ('あんこ', 'いちご')
価格表: {'あんこ': 150, 'いちご': 200}

商品名は何個でもOK

価格表も名前付きで柔軟に追加可能

もちろんです🌸
super() は Python の クラス継承で親クラスのメソッドを呼ぶための便利な関数 です。
初心者向けに、基礎から丁寧に解説します。

1️⃣ super() の基本
ポイント
子クラスで親クラスのメソッドを呼びたいときに使う

多重継承でも 安全に順序通りに呼び出せる

主に __init__（コンストラクタ）でよく使う

2️⃣ 単純な例（親クラスのメソッドを呼ぶ）
class Parent:
    def greet(self):
        print("こんにちは、親クラスです！")

class Child(Parent):
    def greet(self):
        print("子クラスからの挨拶")
        super().greet()  # 親クラスのメソッドを呼ぶ

c = Child()
c.greet()

出力:

子クラスからの挨拶
こんにちは、親クラスです！

💡 解説:

super().greet() で親クラス Parent の greet が呼ばれます

子クラスの処理の前後に親クラスの処理を挿入可能

3️⃣ __init__ でのよくある使い方
class Parent:
    def __init__(self, name):
        self.name = name
        print(f"親クラス初期化: {self.name}")

class Child(Parent):
    def __init__(self, name, age):
        super().__init__(name)  # 親の初期化を呼ぶ
        self.age = age
        print(f"子クラス初期化: {self.age}歳")

c = Child("ゆきこ", 25)

出力:

親クラス初期化: ゆきこ
子クラス初期化: 25歳

💡 解説:

親クラスの __init__ を呼ばないと name が設定されない

super() を使うことで、親クラスの処理も安全に実行できる

4️⃣ 多重継承でも安心
class A:
    def hello(self):
        print("Aクラス")

class B:
    def hello(self):
        print("Bクラス")

class C(A, B):
    def hello(self):
        print("Cクラス")
        super().hello()  # MRO順に呼ばれる

c = C()
c.hello()

出力:

Cクラス
Aクラス

💡 解説:

Python は MRO（Method Resolution Order）という順番で親を探索

super() を使うと、この順番に沿って親クラスのメソッドが呼ばれる

5️⃣ 実務での便利な例（柔軟な継承）
class Shop:
    def __init__(self, name):
        self.name = name
        print(f"{self.name}を開店！")

class OnlineShop(Shop):
    def __init__(self, name, url):
        super().__init__(name)  # 親クラスの初期化
        self.url = url
        print(f"オンラインショップURL: {self.url}")

o = OnlineShop("ふわふわ大福店", "www.daifuku.com")

出力:

ふわふわ大福店を開店！
オンラインショップURL: www.daifuku.com

💡 ポイント:

super() がないと、親クラスの初期化が呼ばれず name が設定されない

子クラスは 追加の処理だけを書けばよい ので楽

✅ まとめ

super() は親クラスのメソッドを呼ぶ安全な方法

特に __init__ でよく使う

多重継承でも MRO に沿って正しい順番で呼ばれる

子クラスは親クラスを再利用できるのでコードが簡潔になる

もちろんです🌸
オーバーライド（override） は 親クラスのメソッドを子クラスで上書きすること を指します。
順を追って丁寧に解説します。

1️⃣ 基本的なオーバーライド
class Parent:
    def greet(self):
        print("こんにちは、親クラスです！")

class Child(Parent):
    def greet(self):  # 親の greet を上書き
        print("こんにちは、子クラスです！")

c = Child()
c.greet()

出力:

こんにちは、子クラスです！

💡 解説:

Child の greet が親の greet を 上書き（オーバーライド）

子クラスのメソッドが優先される

2️⃣ オーバーライド＋親メソッド呼び出し
親の処理も残したい場合は super() と組み合わせます。

class Parent:
    def greet(self):
        print("こんにちは、親クラスです！")

class Child(Parent):
    def greet(self):
        print("子クラスの挨拶前処理")
        super().greet()  # 親クラスのメソッドを呼ぶ
        print("子クラスの挨拶後処理")

c = Child()
c.greet()

出力:

子クラスの挨拶前処理
こんにちは、親クラスです！
子クラスの挨拶後処理

💡 解説:

親クラスのメソッドを残しつつ、子クラスの独自処理を追加可能

上書きと追加処理を両立できる

3️⃣ 実務っぽい例（ふわふわ大福店🍡）
class Daifuku:
    def describe(self):
        print("普通の大福です")

class SpecialDaifuku(Daifuku):
    def describe(self):  # オーバーライド
        print("特製大福です！")
        super().describe()  # 元の説明も追加

d = SpecialDaifuku()
d.describe()

出力:

特製大福です！
普通の大福です

💡 ポイント:

親クラスの「基本説明」を残しつつ、子クラスで「特別な説明」を追加

オーバーライドは 子クラスの個性 を表現するのに便利

もちろんです🌸
ここでは *args と **kwargs を使った柔軟な引数の受け取り方 を丁寧に解説します。

1️⃣ 基本イメージ
*args → 位置引数のタプルとして受け取る

**kwargs → 名前付き引数の辞書として受け取る

def show_args(*args, **kwargs):
    print("args:", args)
    print("kwargs:", kwargs)

show_args(1, 2, 3, a=10, b=20)

出力:

args: (1, 2, 3)
kwargs: {'a': 10, 'b': 20}

💡 解説:

1, 2, 3 は位置引数 → args にタプルとして入る

a=10, b=20 は名前付き引数 → kwargs に辞書として入る

2️⃣ クラス内で使う例（ふわふわ大福店🍡）
class Menu:
    def show_items(self, *items, **prices):
        print("商品リスト:", items)
        print("価格表:", prices)

m = Menu()
m.show_items("あんこ", "いちご", "クリーム", あんこ=150, いちご=200)

出力:

商品リスト: ('あんこ', 'いちご', 'クリーム')
価格表: {'あんこ': 150, 'いちご': 200}

💡 解説:

*items で何個でも商品名を受け取れる

**prices で商品ごとの価格を柔軟に受け取れる

3️⃣ 継承と組み合わせる例
class Base:
    def greet(self, *args, **kwargs):
        print("Baseの挨拶")
        print("args:", args)
        print("kwargs:", kwargs)

class Child(Base):
    def greet(self, *args, **kwargs):
        print("Childの挨拶前処理")
        super().greet(*args, **kwargs)  # 親に引数をそのまま渡す
        print("Childの挨拶後処理")

c = Child()
c.greet("こんにちは", "やあ", name="ゆきこ", mood="楽しい")

出力:

Childの挨拶前処理
Baseの挨拶
args: ('こんにちは', 'やあ')
kwargs: {'name': 'ゆきこ', 'mood': '楽しい'}
Childの挨拶後処理

💡 ポイント:

*args / **kwargs を使うと、親クラスに渡す引数の数や内容を 固定せずに柔軟に継承可能

MRO に沿って安全にメソッドチェーンが作れる

💡 まとめ:

*args → 位置引数のまとめ受け取り

**kwargs → 名前付き引数のまとめ受け取り

継承・オーバーライドでも便利

関数やメソッドを「何でも受け取れる柔軟な形」にできる

いいですね🌸
特殊メソッド（マジックメソッド）は、Pythonが自動で呼び出す特別な関数です。
__init__, __str__, __len__, __add__ など、両端がダブルアンダースコア（__） になっているのが特徴です。

🧩 特殊メソッドとは？
Pythonが「特定のタイミング」で自動的に呼び出すメソッドのこと。
クラスに特別な動きを与えられます。


① __init__（初期化）
インスタンスを作るときに自動で呼ばれる「コンストラクタ」。


class Daifuku:
    def __init__(self, flavor):
        self.flavor = flavor
        print(f"{flavor}大福を作りました！")

d = Daifuku("あんこ")

出力:

あんこ大福を作りました！

💡 __init__ は「インスタンスが作られる瞬間」に1回だけ呼ばれます。

② __str__（文字列化）
print() や str() で表示される内容を定義。


class Daifuku:
    def __init__(self, flavor):
        self.flavor = flavor

    def __str__(self):
        return f"🍡 {self.flavor}大福です！"

d = Daifuku("いちご")
print(d)

出力:

🍡 いちご大福です！

💡 __str__ がないと、<__main__.Daifuku object at 0x...> のような機械的表示になります。

③ __len__（長さ）
len() 関数で返す値を定義。


class Box:
    def __init__(self, *items):
        self.items = items

    def __len__(self):
        return len(self.items)

b = Box("あんこ", "クリーム", "いちご")
print(len(b))

出力:

3

💡 len(b) が内部で b.__len__() を呼んでいます。

④ __add__（+演算子のカスタマイズ）
+ を使ったときの動作を定義できます。


class Daifuku:
    def __init__(self, flavor):
        self.flavor = flavor

    def __add__(self, other):
        return Daifuku(self.flavor + "×" + other.flavor)

    def __str__(self):
        return f"{self.flavor}大福"

d1 = Daifuku("あんこ")
d2 = Daifuku("いちご")
print(d1 + d2)

出力:

あんこ×いちご大福

💡 + を押したとき、内部では d1.__add__(d2) が呼ばれます。

⑤ __eq__（==のカスタマイズ）
== 比較の結果を自分で決められる。


class Daifuku:
    def __init__(self, flavor):
        self.flavor = flavor

    def __eq__(self, other):
        return self.flavor == other.flavor

a = Daifuku("あんこ")
b = Daifuku("あんこ")
c = Daifuku("クリーム")

print(a == b)  # True
print(a == c)  # False

🧾 まとめ表
メソッド名 タイミング 例 __init__ インスタンス生成時 初期化処理 __str__ print()やstr() 表示内容をカスタマイズ __len__ len()呼び出し時 要素数を返す __add__ +演算時 合成・加算の動作定義 __eq__ ==比較時 比較ルール定義

🌸 まとめ：
特殊メソッドを使うと、
自分で作ったクラスを Pythonの標準構文のように自然に使える ようになります。

とっても良い質問です🌸
Pythonの コンストラクタ（constructor） は、
クラスから「インスタンス（実体）」を作るときに 最初に一度だけ自動で実行される 特別なメソッドです。

その正体が __init__() です。
では、やさしく順に見ていきましょう🍡

🧩 1. コンストラクタとは？
クラスからオブジェクト（インスタンス）を作るときに
自動的に呼ばれる初期化メソッド のこと。


Pythonでは必ず __init__() という名前になります。

🍡 2. 基本の書き方
class Daifuku:
    def __init__(self, flavor):
        # ここがコンストラクタ（初期化処理）
        self.flavor = flavor
        print(f"{flavor}大福を作りました！")

# インスタンスを作る（コンストラクタが自動実行）
d = Daifuku("あんこ")

🧠 出力:

あんこ大福を作りました！

💬 解説:

__init__ は 自動で呼ばれる（呼び出す必要はない）

self.flavor は「その大福だけのデータ（インスタンス変数）」

🍰 3. 複数の引数をとる
class Daifuku:
    def __init__(self, flavor, price):
        self.flavor = flavor
        self.price = price
        print(f"{flavor}大福（{price}円）を作りました！")

d = Daifuku("いちご", 200)

🧠 出力：

いちご大福（200円）を作りました！

💡 引数を増やせば、いろんな情報をセットできます。

🏪 4. 初期値（デフォルト値）を設定
class Shop:
    def __init__(self, name="ふわふわ大福店", open_hour=10):
        self.name = name
        self.open_hour = open_hour

s1 = Shop()
s2 = Shop("もちもち屋", 9)

print(s1.name, s1.open_hour)
print(s2.name, s2.open_hour)

🧠 出力：

ふわふわ大福店 10
もちもち屋 9

💡 デフォルト引数を使えば、柔軟な初期化ができます。

🧠 5. super() と一緒に使う（親クラスの初期化）
class Parent:
    def __init__(self):
        print("親クラスの初期化")

class Child(Parent):
    def __init__(self):
        super().__init__()  # 親のコンストラクタを呼ぶ
        print("子クラスの初期化")

c = Child()

🧠 出力：

親クラスの初期化
子クラスの初期化

💬 super() は、
親クラスの __init__ を実行 するための命令です。
多重継承のときも安全に動きます。

🧾 6. まとめ表
内容 説明 キーワード コンストラクタとは インスタンス作成時に自動実行される初期化関数 __init__ self 自分自身のインスタンスを指す self.変数名 デフォルト値 引数に初期値を設定可能 arg=value super() 親クラスの初期化を呼ぶ super().__init__()

🎓 7. 実務的イメージ（まとめ）
class Customer:
    def __init__(self, name, age=20):
        self.name = name
        self.age = age
        print(f"👤 {self.name} さん（{self.age}歳）を登録しました。")

customer1 = Customer("ゆきこ")
customer2 = Customer("だいふく", 25)

🧠 出力：

👤 ゆきこ さん（20歳）を登録しました。
👤 だいふく さん（25歳）を登録しました。

💡 まとめ一言：

__init__ は「クラスのはじまりのあいさつ」みたいなもの。
インスタンスが生まれた瞬間に、最初の準備をしてくれます。


いいですね😊✨
では、今回はコンストラクタの「逆」——
デストラクタ（destructor） について、
ふわふわ大福店🍡の例でやさしく解説します。

🍵 デストラクタ（__del__）とは？
インスタンスが 削除されるとき（寿命が終わるとき） に
自動的に呼び出されるメソッドです。


つまり、

__init__ → はじまりのあいさつ（誕生時）

__del__ → おわりのあいさつ（消滅時）

🍡 1. 基本の使い方
class Daifuku:
    def __init__(self, flavor):
        self.flavor = flavor
        print(f"🍡 {self.flavor}大福を作りました！")

    def __del__(self):
        print(f"💨 {self.flavor}大福を片付けました。")

# インスタンスを作る（__init__呼ばれる）
d = Daifuku("あんこ")

# 明示的に削除（__del__呼ばれる）
del d

🧠 出力:

🍡 あんこ大福を作りました！
💨 あんこ大福を片付けました。

💡 del d で変数 d を削除した瞬間に、__del__() が自動実行されます。

🏪 2. 自動で呼ばれるタイミング
Pythonでは、
「オブジェクトが 誰からも参照されなくなったとき」に自動的に削除されます。

def make_daifuku():
    d = Daifuku("いちご")
    print("🍓 一時的に作ったよ")

make_daifuku()
print("関数が終わったので、自動で削除されます。")

🧠 出力:

🍡 いちご大福を作りました！
🍓 一時的に作ったよ
💨 いちご大福を片付けました。
関数が終わったので、自動で削除されます。

💬 関数が終わると、d が使われなくなるため、自動で __del__ が呼ばれます。

🧠 3. 注意点（デストラクタの落とし穴）
呼ばれるタイミングは保証されません。
→ Pythonの「ガベージコレクション」に依存します。

プログラム終了時などでは、
順序が変わって「呼ばれない」こともあります。

なので、
重要な後処理（ファイルを閉じるなど）は、
デストラクタよりも with 文 や try/finally の方が安全 です。

🧾 4. コンストラクタとデストラクタのペア
class Shop:
    def __init__(self, name):
        self.name = name
        print(f"🏠 {self.name}を開店しました！")

    def __del__(self):
        print(f"🔒 {self.name}を閉店しました。")

shop = Shop("ふわふわ大福店")
print("🍡 営業中...")
del shop

🧠 出力:

🏠 ふわふわ大福店を開店しました！
🍡 営業中...
🔒 ふわふわ大福店を閉店しました。

💡 まとめ表
メソッド名 タイミング 主な役割 呼び出し方法 __init__() インスタンス生成時 初期化 自動 __del__() インスタンス削除時 後片付け 自動 or del

🎓 5. まとめコメント
🧁

__init__ は「こんにちは！」
__del__ は「さようなら！」


というように、
オブジェクトの ライフサイクル（誕生〜終了） を管理できる仕組みです。

すばらしい質問です✨
Pythonの特殊メソッド __add__ は、「+（足し算演算子）」を自作クラスでも使えるようにする魔法の仕組み です！

🍰 __add__とは？
__add__(self, other) は、self + other が呼ばれたときに自動的に実行されるメソッドです。

💬 つまり、「+」の意味をあなたのクラスで自由に定義できる！
🍡 例①：基本的な使い方
class Daifuku:
    def __init__(self, flavor):
        self.flavor = flavor

    def __add__(self, other):
        return Daifuku(self.flavor + "＆" + other.flavor)

    def __str__(self):
        return f"{self.flavor}大福"

# 2つの大福を作る
d1 = Daifuku("あんこ")
d2 = Daifuku("いちご")

# + で「合体」できる！
d3 = d1 + d2
print(d3)

🧠 出力:

あんこ＆いちご大福

✨ __add__ が呼ばれて、
d1 + d2 → Daifuku.__add__(d1, d2) に変換されます！

🍵 例②：数値を扱うクラスでも使える！
class Price:
    def __init__(self, yen):
        self.yen = yen

    def __add__(self, other):
        return Price(self.yen + other.yen)

    def __str__(self):
        return f"{self.yen}円"

p1 = Price(120)
p2 = Price(180)
p3 = p1 + p2
print(p3)

🧠 出力:

300円

💡 こうすると、「Price型 × Price型」の加算ルールを
あなたの思い通りに定義できます！

🍬 例③：他の型（intなど）もOKにするには？
class Price:
    def __init__(self, yen):
        self.yen = yen

    def __add__(self, other):
        if isinstance(other, Price):
            return Price(self.yen + other.yen)
        elif isinstance(other, int):
            return Price(self.yen + other)
        else:
            return NotImplemented  # 対応してない型

    def __str__(self):
        return f"{self.yen}円"

p = Price(100)
print(p + 50)   # 150円
print(p + Price(30))  # 130円

🧠 出力:

150円
130円

🎓 例④：逆方向の加算（__radd__）
もし int + Price のように 左側が組み込み型 の場合は、
__radd__（right add）が呼ばれます。

class Price:
    def __init__(self, yen):
        self.yen = yen

    def __add__(self, other):
        if isinstance(other, Price):
            return Price(self.yen + other.yen)
        elif isinstance(other, int):
            return Price(self.yen + other)
        return NotImplemented

    def __radd__(self, other):
        # int + Price の場合
        return self.__add__(other)

    def __str__(self):
        return f"{self.yen}円"

p = Price(100)
print(50 + p)  # __radd__が呼ばれる！

🧠 出力:

150円

🧾 まとめ表
特殊メソッド 意味 呼ばれるタイミング __add__(self, other) self + other 左側のオブジェクトが呼び出す __radd__(self, other) other + self 右側のオブジェクトが呼び出す（左が未対応の場合）

 まとめ

__add__ は「+」のふるまいを再定義できるメソッド。
数値の足し算だけでなく、
「大福を組み合わせる」「データをマージする」など
独自の“加算の意味” を自由に作れます！

完璧な流れです👏✨
特殊メソッドの中でも __sub__ / __eq__ / __repr__ / __str__ は、
「Pythonの魔法のふるまい」を理解する上でとても大事です。

では、ひとつずつ丁寧に解説します！
（最後に全部まとめた比較表もつけます📘）

🥇 ① __sub__（マイナスのオーバーロード）
__sub__(self, other) は self - other のときに呼ばれます。
「−（引き算）」の意味を自由に決められる！


🍡 例：Price クラスで差をとる
class Price:
    def __init__(self, yen):
        self.yen = yen

    def __sub__(self, other):
        return Price(self.yen - other.yen)

    def __str__(self):
        return f"{self.yen}円"

p1 = Price(300)
p2 = Price(120)
print(p1 - p2)

🧠 出力：

180円

💬 p1 - p2 → Price.__sub__(p1, p2)
これで 「Price型同士の引き算」 を定義できます。

🍵 intにも対応する例：
class Price:
    def __init__(self, yen):
        self.yen = yen

    def __sub__(self, other):
        if isinstance(other, int):
            return Price(self.yen - other)
        elif isinstance(other, Price):
            return Price(self.yen - other.yen)
        return NotImplemented

    def __rsub__(self, other):
        # int - Price の場合
        if isinstance(other, int):
            return Price(other - self.yen)
        return NotImplemented

    def __str__(self):
        return f"{self.yen}円"

p = Price(150)
print(p - 30)   # 120円
print(200 - p)  # 50円

🥈 ② __eq__（== のオーバーロード）
__eq__(self, other) は self == other のときに呼ばれます。
オブジェクトの「等しい」を自分で定義できる！


🍰 例：同じ値段なら同じとみなす
class Price:
    def __init__(self, yen):
        self.yen = yen

    def __eq__(self, other):
        if isinstance(other, Price):
            return self.yen == other.yen
        return False

p1 = Price(100)
p2 = Price(100)
p3 = Price(200)

print(p1 == p2)  # True
print(p1 == p3)  # False

🧠 出力：

True
False

💬 デフォルトでは「同じオブジェクトかどうか」しか見ませんが、
__eq__を定義することで「中身が同じならTrue」にできます！

🥉 ③ __repr__ / __str__（表示の違い）
__repr__: 開発者向けの表示（デバッグ用）
__str__: 一般ユーザー向けの表示（print用）


🍵 例：違いを体験しよう
class Price:
    def __init__(self, yen):
        self.yen = yen

    def __repr__(self):
        return f"Price(yen={self.yen})"  # デバッグ用

    def __str__(self):
        return f"{self.yen}円"  # ユーザー表示用

p = Price(120)
print(p)       # __str__が呼ばれる
p               # 対話モードでは__repr__が呼ばれる

🧠 出力（ターミナルで実行すると）

120円
Price(yen=120)

💬

print(p) → ユーザー向けのきれいな表示

p だけ → 開発者が見る内部的な情報

🎓 まとめ表
メソッド名 演算子 / 動作 例 目的 __add__ + a + b 加算（合体なども定義可） __sub__ - a - b 引き算（差を取る） __eq__ == a == b 等価比較を定義 __repr__ repr(obj) / REPL表示 Price(yen=100) デバッグ用表示 __str__ print(obj) 100円 一般ユーザー向け表示

 まとめコメント
特殊メソッドは「演算子や関数の裏側で呼ばれる仕組み」！

たとえば：

+ → __add__

- → __sub__

== → __eq__

print() → __str__

REPL表示 → __repr__

これを理解すると
「クラスをまるで組み込み型みたいに使える」
＝ Pythonらしいオブジェクト指向の第一歩！



ポイントのまとめ表




その他押さえておきたい文法の概要








https://github.com/Forbusinessuseyukikoishiguro/Python-20251004-Selenium-/tree/main
現在の縮小状態：拡大現在の縮小状態：縮小

画像がアップロードされました
下書きを保存しました
記事編集 | note
AIと相談


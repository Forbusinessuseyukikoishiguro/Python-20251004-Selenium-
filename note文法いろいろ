





目次
🐰 ふわふわ大福店うさうさ - Python文法学習プログラム
🎯 このコードを実行すると...
📚 学べる内容
💡 使い方
おまけ基礎文法概要
Python文法ガイド - やさしく解説
① 基本文法レベル（初心者〜中級者）
リスト内包表記
辞書内包表記
条件式（三項演算子）
アンパッキング代入
f文字列
enumerate()
zip()
② 応用構文レベル（中級者〜上級者）
with文（コンテキストマネージャ）
try-except-else-finally
関数デフォルト引数
**可変長引数（*args, kwargs）
ラムダ式
ジェネレータ（yield）
③ Pythonic表現（慣用的・読みやすい書き方）
if x in list
any / all
辞書のget()
文字列スライス
"".join()
辞書反転
④ 高度構文・設計パターン（上級者）
デコレータ
クラス継承
抽象基底クラス（ABC）
プロパティ（@property）
型ヒント
内包辞書・条件
🎯 学習のコツ
17,910 文字

閉じる


下書き保存

公開に進む

🐰うさうさ - Python文法学習プログラム
テキスト未選択のときにタブキーでメニューボタンへ移動できます
🐰 ふわふわ大福店うさうさ - Python文法学習プログラム
目次
🐰 ふわふわ大福店うさうさ - Python文法学習プログラム
🎯 このコードを実行すると...
📚 学べる内容
💡 使い方
おまけ基礎文法概要
Python文法ガイド - やさしく解説
① 基本文法レベル（初心者〜中級者）
リスト内包表記
辞書内包表記
条件式（三項演算子）
アンパッキング代入
f文字列
enumerate()
zip()
② 応用構文レベル（中級者〜上級者）
with文（コンテキストマネージャ）
try-except-else-finally
関数デフォルト引数
**可変長引数（*args, kwargs）
ラムダ式
ジェネレータ（yield）
③ Pythonic表現（慣用的・読みやすい書き方）
if x in list
any / all
辞書のget()
文字列スライス
"".join()
辞書反転
④ 高度構文・設計パターン（上級者）
デコレータ
クラス継承
抽象基底クラス（ABC）
プロパティ（@property）
型ヒント
内包辞書・条件
🎯 学習のコツ
それでは、うさうさ店長と一緒に大福屋さんを経営しながら、Python文法を学びましょう！

# ============================================
# 🐰 ふわふわ大福店うさうさ - Python文法デモ
# ============================================

# --- ① 基本文法レベル ---

print("🐰 うさうさ店長：ようこそ、ふわふわ大福店へ！")
print("=" * 50)

# 【リスト内包表記】
# 通常のfor文の代わりに、1行でリストを作成する方法
# [式 for 変数 in イテラブル] の形式
daifuku_prices = [price * 1.1 for price in [100, 150, 200, 250, 300]]
# 各大福の価格に消費税10%を加算したリストを作成
print("\n📝 リスト内包表記で消費税計算:")
print(f"税込み価格: {daifuku_prices}")
# f文字列: f"..." の中で{変数}を使うと、変数の値を埋め込める

# 【辞書内包表記 & zip()】
# zip()は2つのリストを組み合わせてペアを作る関数
# dict()で辞書に変換
daifuku_names = ["いちご", "抹茶", "あんこ", "栗", "チョコ"]
# 大福の名前リスト
daifuku_menu = dict(zip(daifuku_names, daifuku_prices))
# zip()で名前と価格をペアにして、dict()で辞書に変換
print("\n📋 メニュー（辞書）:")
# 辞書はキー:値のペアでデータを保存
for name, price in daifuku_menu.items():
    # .items()で辞書のキーと値を両方取得
    print(f"  {name}大福: {price:.0f}円")
    # :.0fは小数点以下0桁で表示（整数表示）

# 【条件式（三項演算子）】
# 値 = 真の場合の値 if 条件 else 偽の場合の値
customer_age = 15
# お客さんの年齢を設定
discount_rate = 0.2 if customer_age < 18 else 0.1
# 18歳未満なら20%割引、それ以外は10%割引
print(f"\n🎫 {customer_age}歳のお客様の割引率: {discount_rate * 100:.0f}%")
# 割引率を％表示（0.2 → 20%）

# 【アンパッキング代入】
# リストの要素を複数の変数に一度に代入
best_sellers = ["いちご大福", "抹茶大福", "あんこ大福", "栗大福", "チョコ大福"]
# 人気商品リスト
first, second, *others = best_sellers
# firstに1番目、secondに2番目、*othersに残り全部を代入
print(f"\n🏆 人気ランキング:")
print(f"  1位: {first}")
# 1位の商品
print(f"  2位: {second}")
# 2位の商品
print(f"  3位以下: {', '.join(others)}")
# .join()でリストを文字列に結合（カンマ区切り）

# 【enumerate()】
# リストをループする際に、インデックス（番号）も一緒に取得
print(f"\n📊 全ランキング:")
for rank, item in enumerate(best_sellers, 1):
    # enumerate(リスト, 開始番号)で番号付きループ
    # rankに順位、itemに商品名が入る
    print(f"  {rank}位: {item}")
    # 順位と商品名を表示

# 【f文字列】
# 文字列の中に変数を埋め込む最も読みやすい方法
store_name = "ふわふわ大福店うさうさ"
# 店名を変数に保存
owner = "うさうさ店長"
# 店長名を変数に保存
opening_year = 2020
# 開店年を変数に保存
introduction = f"🐰 {store_name}は{opening_year}年に{owner}が開店しました！"
# f"..."の中で{変数名}を使うと、変数の値が埋め込まれる
print(f"\n{introduction}")
# f文字列を表示

print("\n" + "=" * 50)
print("\n🐰 うさうさ店長：次は応用編だよ！")
print("=" * 50)

# --- ② 応用構文レベル ---

# 【with文（コンテキストマネージャ）】
# ファイルを開いて自動的に閉じる安全な方法
print("\n💾 本日の売上を記録中...")
with open("sales.txt", "w", encoding="utf-8") as file:
    # open()でファイルを開く（"w"は書き込みモード）
    # withブロックを抜けると自動的にファイルが閉じられる
    # encoding="utf-8"で日本語対応
    file.write("🐰 ふわふわ大福店うさうさ 売上記録\n")
    # ファイルに1行書き込む（\nは改行）
    file.write("=" * 30 + "\n")
    # 区切り線を書き込む
    for name, price in daifuku_menu.items():
        # メニューの各商品についてループ
        file.write(f"{name}大福: {price:.0f}円\n")
        # 商品名と価格をファイルに書き込む
print("✅ 売上記録完了！（sales.txtに保存）")
# withブロックを抜けた時点でファイルは自動的に閉じられている

# 【try-except-else-finally】
# エラーが起きても�プログラムを止めずに処理を続ける方法
print("\n🧮 注文計算システム:")
order_count = 5
# 注文個数
total_stock = 10
# 在庫数
try:
    # エラーが起きるかもしれない処理を書く
    if order_count > total_stock:
        # 注文が在庫より多い場合
        raise ValueError("在庫不足です！")
        # わざとエラーを発生させる
    result = total_stock - order_count
    # 在庫から注文数を引く
except ValueError as e:
    # ValueErrorが発生した場合の処理
    # eにエラーメッセージが入る
    print(f"  ❌ エラー: {e}")
    # エラーメッセージを表示
    result = 0
    # 結果を0にする
else:
    # エラーが発生しなかった場合の処理
    print(f"  ✅ 注文受付: {order_count}個")
    # 注文受付メッセージ
    print(f"  📦 残り在庫: {result}個")
    # 残り在庫を表示
finally:
    # エラーの有無に関わらず必ず実行される処理
    print(f"  🔄 在庫チェック完了")
    # 処理完了メッセージ

# 【関数デフォルト引数】
# 引数に初期値を設定することで、省略可能にする
def make_daifuku(flavor, size="M", gift_wrap=False):
    # flavor: 必須引数（必ず指定）
    # size: デフォルト引数（省略時は"M"）
    # gift_wrap: デフォルト引数（省略時はFalse）
    message = f"🎁 {size}サイズの{flavor}大福"
    # 基本メッセージを作成
    if gift_wrap:
        # gift_wrapがTrueの場合
        message += "（ラッピング付き）"
        # メッセージに追加
    return message
    # 完成したメッセージを返す

print("\n🎨 大福製造:")
print(f"  {make_daifuku('いちご')}")
# sizeとgift_wrapは省略（デフォルト値使用）
print(f"  {make_daifuku('抹茶', 'L')}")
# gift_wrapのみ省略
print(f"  {make_daifuku('あんこ', 'S', True)}")
# 全て指定

# 【可変長引数（*args, **kwargs）】
# 個数が決まっていない引数を受け取る方法
def calculate_total(*prices, tax_rate=0.1):
    # *prices: 任意の個数の引数をタプルとして受け取る
    # tax_rate: キーワード引数（名前付き引数）
    subtotal = sum(prices)
    # sum()で全ての価格を合計
    tax = subtotal * tax_rate
    # 消費税を計算
    total = subtotal + tax
    # 合計金額を計算
    return subtotal, tax, total
    # 3つの値を返す（タプルとして返される）

print("\n💰 会計システム:")
subtotal, tax, total = calculate_total(110, 165, 220)
# 3つの価格を渡して、3つの結果を受け取る（アンパッキング）
print(f"  小計: {subtotal:.0f}円")
# 小計を表示
print(f"  消費税: {tax:.0f}円")
# 消費税を表示
print(f"  合計: {total:.0f}円")
# 合計を表示

def show_order_details(**details):
    # **details: 任意の個数のキーワード引数を辞書として受け取る
    print("\n📋 注文詳細:")
    for key, value in details.items():
        # 辞書のキーと値をループ
        print(f"  {key}: {value}")
        # キーと値を表示

show_order_details(商品="いちご大福", 個数=3, お客様名="うさこさん", ポイント使用=True)
# キーワード引数として渡すと、辞書として受け取れる

# 【ラムダ式】
# 小さな関数を1行で書く方法（名前のない関数）
sales_data = [
    ("いちご大福", 45),   # (商品名, 販売個数)のタプル
    ("抹茶大福", 38),
    ("あんこ大福", 52),
    ("栗大福", 29),
    ("チョコ大福", 41)
]
print("\n📈 販売個数でソート:")
sorted_sales = sorted(sales_data, key=lambda x: x[1], reverse=True)
# sorted(): リストをソート（並び替え）
# key=lambda x: x[1]: x[1]（2番目の要素=個数）でソート
# reverse=True: 降順（大きい順）
# lambdaは「x を受け取って x[1] を返す関数」を意味する
for item, count in sorted_sales:
    # ソートされたリストをループ
    print(f"  {item}: {count}個")
    # 商品名と個数を表示

# 【ジェネレータ（yield）】
# メモリを節約しながら大量のデータを処理する方法
def daifuku_production(count):
    # 大福を1つずつ生成する関数
    for i in range(1, count + 1):
        # 1からcountまでループ
        yield f"🍡 大福 No.{i}"
        # yieldで値を1つ返して一時停止
        # 次に呼ばれたら続きから実行される

print("\n🏭 大福製造ライン:")
for daifuku in daifuku_production(5):
    # ジェネレータから1つずつ値を取り出す
    print(f"  製造: {daifuku}")
    # 製造された大福を表示
    # メモリには1個分しか保存されない（効率的）

print("\n" + "=" * 50)
print("\n🐰 うさうさ店長：Pythonic表現も見てみよう！")
print("=" * 50)

# --- ③ Pythonic表現 ---

# 【if x in list】
# リストに要素が含まれているかチェックする簡潔な方法
available_flavors = ["いちご", "抹茶", "あんこ", "栗", "チョコ"]
# 利用可能なフレーバーリスト
requested_flavor = "抹茶"
# お客さんのリクエスト

print(f"\n🔍 在庫確認:")
if requested_flavor in available_flavors:
    # inを使って、リストに含まれているかチェック
    # これだけで「抹茶がリストにあるか」を判定できる
    print(f"  ✅ {requested_flavor}大福、ご用意できます！")
else:
    # リストに含まれていない場合
    print(f"  ❌ {requested_flavor}大福は現在品切れです")

# 【any / all】
# リストの要素が条件を満たすかチェックする便利な関数
stock_counts = [5, 3, 8, 0, 12]
# 各商品の在庫数リスト

print(f"\n📊 在庫状況チェック:")
if any(count == 0 for count in stock_counts):
    # any(): 1つでもTrueがあればTrue
    # (count == 0 for ...) は各要素が0かチェック
    print(f"  ⚠️  品切れ商品があります！")
    # 0が1つでもあれば警告

if all(count > 0 for count in stock_counts):
    # all(): 全てTrueならTrue
    # 全ての在庫が0より大きいかチェック
    print(f"  ✅ 全商品在庫あり")
else:
    # 1つでも0以下があれば
    print(f"  ⚠️  一部商品が品切れ")

# 【辞書のget()】
# 辞書からキーを安全に取り出す方法（エラーを防ぐ）
customer_points = {
    "うさこさん": 150,
    "くまおさん": 230,
    "ねこみさん": 80
}
# 顧客ポイント辞書

print(f"\n🎁 ポイント照会:")
customer_name = "うさこさん"
# 照会する顧客名
points = customer_points.get(customer_name, 0)
# .get(キー, デフォルト値)
# キーが存在すればその値、なければデフォルト値を返す
# これでKeyErrorを防げる
print(f"  {customer_name}のポイント: {points}pt")

new_customer = "りすきさん"
# 新しいお客さん（辞書に未登録）
points = customer_points.get(new_customer, 0)
# 存在しないキーでもエラーにならず0を返す
print(f"  {new_customer}のポイント: {points}pt（新規）")

# 【文字列スライス】
# 文字列の一部を切り出す便利な方法
store_name = "ふわふわ大福店うさうさ"
# 文字列を定義

print(f"\n✂️  文字列スライス:")
print(f"  最初の4文字: {store_name[:4]}")
# [:4] = 先頭から4文字目まで
print(f"  最後の5文字: {store_name[-5:]}")
# [-5:] = 後ろから5文字目以降
print(f"  逆から読むと: {store_name[::-1]}")
# [::-1] = 文字列を逆順に

# 【"".join()】
# リストの要素を文字列に結合する効率的な方法
ingredients = ["もち粉", "砂糖", "水", "いちご", "あんこ"]
# 材料リスト

print(f"\n🥘 材料リスト:")
recipe = "、".join(ingredients)
# .join()でリストを文字列に結合
# "区切り文字".join(リスト) の形式
# この方法が最も効率的（+演算子より高速）
print(f"  {recipe}")

# 【辞書反転】
# 辞書のキーと値を入れ替える方法
price_to_item = {
    "いちご": 110,
    "抹茶": 165,
    "あんこ": 220
}
# 商品名→価格の辞書

print(f"\n🔄 辞書反転（価格→商品名）:")
item_to_price = {price: name for name, price in price_to_item.items()}
# 辞書内包表記でキーと値を入れ替え
# {新しい値: 新しいキー for キー, 値 in 元の辞書.items()}
for price, name in sorted(item_to_price.items()):
    # sorted()で価格順にソート
    print(f"  {price}円: {name}大福")

print("\n" + "=" * 50)
print("\n🐰 うさうさ店長：最後は上級編だよ！")
print("=" * 50)

# --- ④ 高度構文・設計パターン ---

# 【デコレータ】
# 関数に機能を追加する装飾的な仕組み
def log_sales(func):
    # デコレータ関数（他の関数を装飾する）
    def wrapper(*args, **kwargs):
        # ラッパー関数（元の関数を包む）
        print(f"  📝 販売記録開始...")
        # 関数実行前の処理
        result = func(*args, **kwargs)
        # 元の関数を実行
        print(f"  ✅ 販売記録完了")
        # 関数実行後の処理
        return result
        # 結果を返す
    return wrapper
    # ラッパー関数を返す

@log_sales
# @デコレータ名 で関数を装飾
# sell_daifuku = log_sales(sell_daifuku) と同じ意味
def sell_daifuku(flavor, quantity):
    # 大福を販売する関数
    print(f"    🛒 {flavor}大福を{quantity}個販売")
    return quantity * 110
    # 売上金額を返す

print(f"\n💼 販売処理（デコレータ付き）:")
total = sell_daifuku("いちご", 3)
# デコレータにより、前後の処理が自動追加される
print(f"  売上: {total}円")

# 【クラス継承】
# クラスの機能を引き継いで拡張する方法
class Product:
    # 親クラス（基本的な商品クラス）
    def __init__(self, name, price):
        # コンストラクタ（インスタンス作成時に実行）
        self.name = name
        # インスタンス変数（名前）
        self.price = price
        # インスタンス変数（価格）
    
    def display(self):
        # メソッド（インスタンスが持つ関数）
        return f"{self.name}: {self.price}円"
        # 商品情報を返す

class PremiumDaifuku(Product):
    # 子クラス（Productを継承）
    def __init__(self, name, price, special_ingredient):
        # 子クラスのコンストラクタ
        super().__init__(name, price)
        # super()で親クラスのコンストラクタを呼び出す
        # これでnameとpriceを設定
        self.special_ingredient = special_ingredient
        # 子クラス独自の属性を追加
    
    def display(self):
        # メソッドのオーバーライド（上書き）
        base = super().display()
        # 親クラスのdisplay()を呼び出す
        return f"⭐ {base}（{self.special_ingredient}使用）"
        # 親の結果に特別な情報を追加

print(f"\n🎨 商品クラス:")
normal = Product("あんこ大福", 110)
# 通常の商品インスタンス作成
print(f"  {normal.display()}")
# 通常の表示

premium = PremiumDaifuku("特選いちご大福", 330, "とちおとめ")
# プレミアム商品インスタンス作成
print(f"  {premium.display()}")
# 特別な表示

# 【抽象基底クラス（ABC）】
# 設計図として使い、継承を強制するクラス
from abc import ABC, abstractmethod
# ABCとabstractmethodをインポート

class DaifukuBase(ABC):
    # 抽象クラス（ABCを継承）
    # このクラス自体はインスタンス化できない
    @abstractmethod
    def make(self):
        # 抽象メソッド（実装を強制）
        # 子クラスで必ずこのメソッドを実装しないとエラー
        pass
        # 中身は書かない（passは何もしない）

class StrawberryDaifuku(DaifukuBase):
    # 抽象クラスを継承
    def make(self):
        # 抽象メソッドを実装（必須）
        return "🍓 いちご大福を作りました！"
        # 具体的な処理を書く

print(f"\n🏭 抽象クラスパターン:")
strawberry = StrawberryDaifuku()
# インスタンス作成
print(f"  {strawberry.make()}")
# makeメソッドを呼び出し

# 【プロパティ（@property）】
# メソッドを属性のように使える仕組み
class DaifukuShop:
    # 大福店クラス
    def __init__(self):
        # コンストラクタ
        self._sales = 0
        # アンダースコアは「内部用」を示す慣習
        # 直接アクセスしない方が良い
    
    @property
    # @propertyデコレータでgetterメソッドにする
    def sales(self):
        # メソッドだが、属性のようにアクセスできる
        return f"{self._sales}円"
        # 整形した売上を返す
    
    @sales.setter
    # @属性名.setterでsetterメソッドにする
    def sales(self, value):
        # 値を設定する際の処理
        if value >= 0:
            # 負の値をチェック
            self._sales = value
            # 正の値のみ設定
        else:
            print("  ⚠️  売上は0以上で設定してください")

print(f"\n🏪 プロパティパターン:")
shop = DaifukuShop()
# インスタンス作成
shop.sales = 5500
# setter経由で値を設定（メソッドだが属性のように書ける）
print(f"  本日の売上: {shop.sales}")
# getter経由で値を取得（メソッドだが()不要）

# 【型ヒント】
# コードの意図を明確にする型情報
def calculate_discount(price: int, rate: float) -> int:
    # price: int → priceはint型
    # rate: float → rateはfloat型
    # -> int → 戻り値はint型
    # 実行には影響しないが、コードの理解やエラー検出に役立つ
    return int(price * (1 - rate))
    # 割引後の価格を整数で返す

print(f"\n🏷️  型ヒント:")
discounted = calculate_discount(1000, 0.2)
# 型が明確なので使いやすい
print(f"  割引後: {discounted}円")

# 【内包辞書・条件】
# 辞書内包表記に条件を付ける
all_items = {
    "いちご大福": 110,
    "抹茶大福": 165,
    "あんこ大福": 220,
    "栗大福": 275,
    "チョコ大福": 330
}
# 全商品の辞書

print(f"\n💰 200円以下の商品:")
affordable = {name: price for name, price in all_items.items() if price <= 200}
# {キー: 値 for キー, 値 in 辞書.items() if 条件}
# 条件を満たすものだけを新しい辞書に
for name, price in affordable.items():
    # フィルタリングされた辞書をループ
    print(f"  {name}: {price}円")

print("\n" + "=" * 50)
print("🐰 うさうさ店長：お疲れ様でした！")
print("   全ての文法を大福屋さんで学べたね！🍡")
print("=" * 50)

🎯 このコードを実行すると...
各Python文法を「ふわふわ大福店うさうさ」の運営を通して学べます！

📚 学べる内容
基本文法: リスト内包表記、辞書操作、条件式など

応用構文: ファイル操作、エラー処理、関数の応用

Pythonic表現: Pythonらしい書き方

上級パターン: デコレータ、クラス、型ヒント

💡 使い方
# ファイルに保存して実行
python usausa_daifuku_shop.py

おまけ基礎文法概要
Python文法ガイド - やさしく解説
画像の内容を、初心者の方にもわかりやすく解説しますね！

① 基本文法レベル（初心者〜中級者）
リスト内包表記
# 普通の書き方
numbers = []
for i in range(5):
    numbers.append(i * 2)

# リスト内包表記（スマートな書き方）
numbers = [i * 2 for i in range(5)]
# 結果: [0, 2, 4, 6, 8]

📝 1行で簡潔にリストを作れます

辞書内包表記
# 辞書をまとめて作成
keys = ['a', 'b', 'c']
values = [1, 2, 3]

# dict()を使った方法
my_dict = dict(zip(keys, values))
# 結果: {'a': 1, 'b': 2, 'c': 3}

📝 キーと値をペアにして辞書を作ります

条件式（三項演算子）
age = 20

# 普通のif文
if age >= 18:
    message = "成人"
else:
    message = "未成年"

# 条件式（1行で書ける）
message = "成人" if age >= 18 else "未成年"

📝 シンプルな条件分岐を1行で書けます

アンパッキング代入
# リストの値を複数の変数に分ける
fruits = ['りんご', 'バナナ', 'オレンジ']
a, b, c = fruits
# a='りんご', b='バナナ', c='オレンジ'

# *を使って残りをまとめる
first, *rest = [1, 2, 3, 4, 5]
# first=1, rest=[2, 3, 4, 5]

📝 複数の値を一度に変数に入れられます

f文字列
name = "太郎"
age = 25

# 古い方法
message = "私は" + name + "で、" + str(age) + "歳です"

# f文字列（読みやすい！）
message = f"私は{name}で、{age}歳です"

📝 変数を{}で囲むだけで文字列に埋め込めます

enumerate()
fruits = ['りんご', 'バナナ', 'オレンジ']

# 普通の書き方
for i in range(len(fruits)):
    print(f"{i}: {fruits[i]}")

# enumerate（スマート）
for i, fruit in enumerate(fruits):
    print(f"{i}: {fruit}")
# 0: りんご
# 1: バナナ
# 2: オレンジ

📝 インデックス付きでループできます

zip()
names = ['太郎', '花子', '次郎']
ages = [25, 30, 22]

# 2つのリストを同時に処理
for name, age in zip(names, ages):
    print(f"{name}は{age}歳")
# 太郎は25歳
# 花子は30歳
# 次郎は22歳

📝 複数のリストを同時にループできます

② 応用構文レベル（中級者〜上級者）
with文（コンテキストマネージャ）
# 古い書き方（閉じ忘れの危険！）
file = open('data.txt', 'r')
content = file.read()
file.close()

# with文（自動的に閉じてくれる）
with open('data.txt', 'r') as file:
    content = file.read()
# ブロックを抜けると自動でファイルが閉じる

📝 ファイルやリソースを安全に扱えます

try-except-else-finally
try:
    # エラーが起こるかもしれない処理
    result = 10 / 2
except ZeroDivisionError:
    # エラーが起きたときの処理
    print("0で割れません")
else:
    # エラーが起きなかったときの処理
    print(f"結果: {result}")
finally:
    # 必ず実行される処理
    print("計算終了")

📝 エラー処理を細かく制御できます

関数デフォルト引数
# デフォルト値を設定
def greet(name, greeting="こんにちは"):
    return f"{greeting}、{name}さん"

print(greet("太郎"))              # こんにちは、太郎さん
print(greet("花子", "おはよう"))   # おはよう、花子さん

📝 引数を省略できるようになります

**可変長引数（*args, kwargs）
# *args: 複数の引数をタプルで受け取る
def add_all(*numbers):
    return sum(numbers)

print(add_all(1, 2, 3, 4))  # 10

# **kwargs: キーワード引数を辞書で受け取る
def show_info(**info):
    for key, value in info.items():
        print(f"{key}: {value}")

show_info(名前="太郎", 年齢=25, 職業="エンジニア")

📝 柔軟な数の引数を受け取れます

ラムダ式
# 普通の関数
def double(x):
    return x * 2

# ラムダ式（無名関数）
double = lambda x: x * 2

# よく使う例：sortのキーとして
students = [('太郎', 85), ('花子', 92), ('次郎', 78)]
students.sort(key=lambda x: x[1])  # 点数でソート

📝 簡単な関数を1行で書けます

ジェネレータ（yield）
# 普通の関数（全部メモリに保存）
def get_numbers():
    return [0, 1, 2, 3, 4]

# ジェネレータ（1つずつ生成）
def get_numbers_gen():
    for i in range(5):
        yield i  # 値を1つ返して一時停止

# 使い方
for num in get_numbers_gen():
    print(num)  # メモリ効率が良い

📝 大量のデータを効率的に処理できます

③ Pythonic表現（慣用的・読みやすい書き方）
if x in list
# 悪い例
fruits = ['りんご', 'バナナ']
found = False
for fruit in fruits:
    if fruit == 'りんご':
        found = True

# 良い例（Pythonic）
if 'りんご' in fruits:
    print("見つかった！")

📝 シンプルで読みやすいです

any / all
numbers = [1, 2, 3, 4, 5]

# どれか1つでも偶数か？
if any(n % 2 == 0 for n in numbers):
    print("偶数がある")

# 全部正の数か？
if all(n > 0 for n in numbers):
    print("全部正の数")

📝 条件チェックが簡潔に書けます

辞書のget()
person = {'名前': '太郎', '年齢': 25}

# 悪い例（キーがないとエラー）
# address = person['住所']  # KeyError!

# 良い例（デフォルト値を返す）
address = person.get('住所', '不明')

📝 安全にデフォルト値を設定できます

文字列スライス
text = "Python"

# 最初の3文字
print(text[:3])     # Pyt

# 最後の3文字
print(text[-3:])    # hon

# 逆順
print(text[::-1])   # nohtyP

📝 文字列を柔軟に切り出せます

"".join()
words = ['Python', 'は', '楽しい']

# 悪い例
result = ""
for word in words:
    result += word

# 良い例（高速）
result = "".join(words)       # Pythonは楽しい
result = " ".join(words)      # Python は 楽しい

📝 文字列結合の標準的な方法です

辞書反転
original = {'a': 1, 'b': 2, 'c': 3}

# キーと値を入れ替え
reversed_dict = {v: k for k, v in original.items()}
# 結果: {1: 'a', 2: 'b', 3: 'c'}

📝 辞書のキーと値を簡単に入れ替えられます

④ 高度構文・設計パターン（上級者）
デコレータ
# 関数の前後に処理を追加
def timer(func):
    def wrapper(*args, **kwargs):
        print("開始")
        result = func(*args, **kwargs)
        print("終了")
        return result
    return wrapper

@timer  # デコレータを適用
def say_hello():
    print("こんにちは")

say_hello()
# 開始
# こんにちは
# 終了

📝 関数に機能を追加できます

クラス継承
# 親クラス
class Animal:
    def speak(self):
        return "何か音を出す"

# 子クラス（継承）
class Dog(Animal):
    def speak(self):
        return "ワンワン"

dog = Dog()
print(dog.speak())  # ワンワン

📝 コードを再利用して拡張できます

抽象基底クラス（ABC）
from abc import ABC, abstractmethod

# 抽象クラス（設計図）
class Shape(ABC):
    @abstractmethod
    def area(self):
        pass  # 子クラスで必ず実装が必要

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14 * self.radius ** 2

📝 統一的なインターフェースを強制できます

プロパティ（@property）
class Person:
    def __init__(self, name):
        self._name = name
    
    @property  # getterメソッド
    def name(self):
        return self._name
    
    @name.setter  # setterメソッド
    def name(self, value):
        if value:
            self._name = value

person = Person("太郎")
print(person.name)     # 太郎（メソッドだけど属性のように使える）
person.name = "花子"   # setterが呼ばれる

📝 属性アクセスを制御できます

型ヒント
# 型を明示（実行には影響しない）
def add(a: int, b: int) -> int:
    return a + b

# リストや辞書の型も指定できる
from typing import List, Dict

def process_items(items: List[str]) -> Dict[str, int]:
    return {item: len(item) for item in items}

📝 コードの意図が明確になり、エラーを防げます

内包辞書・条件
# 条件付き辞書内包表記
numbers = [1, 2, 3, 4, 5, 6]

# 偶数だけを2乗
squared_evens = {n: n**2 for n in numbers if n % 2 == 0}
# 結果: {2: 4, 4: 16, 6: 36}

📝 フィルタリングと変換を同時にできます

🎯 学習のコツ
基本から順番に: ①→②→③→④の順で学ぶのがおすすめ

実際に書く: コードを読むだけでなく、自分で書いて試す

小さく始める: 最初は簡単な例から、徐々に複雑にする

エラーを恐れない: エラーは学びのチャンス！

何か質問があれば、お気軽に聞いてくださいね！😊

現在の縮小状態：拡大現在の縮小状態：縮小

記事編集 | note
AIと相談


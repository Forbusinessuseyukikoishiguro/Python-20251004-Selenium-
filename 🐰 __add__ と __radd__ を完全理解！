# 🐰 `__add__` と `__radd__` を完全理解！

うさうさ店長が、超わかりやすく解説するよ！

---

## 🎯 結論を先に！

```python
# ✅ これだけ覚えればOK！

# obj + 100  →  obj.__add__(100) が呼ばれる
# 100 + obj  →  obj.__radd__(100) が呼ばれる

# 💡 左側が自分のクラス → __add__
# 💡 右側が自分のクラス → __radd__
```

---

## 🍡 超シンプルな例で理解しよう

### ステップ1️⃣：`__add__` だけの場合

```python
class Daifuku:
    def __init__(self, price):
        self.price = price  # 価格
    
    def __add__(self, other):
        """
        Daifuku + 何か の計算
        """
        print(f"🔵 __add__が呼ばれた！")
        print(f"   左側(self): {self.price}円の大福")
        print(f"   右側(other): {other}")
        return Daifuku(self.price + other)
    
    def __str__(self):
        return f"{self.price}円"

# 大福を作る
daifuku = Daifuku(100)  # 100円の大福

print("=" * 50)
print("テスト1: daifuku + 50")
print("=" * 50)
result = daifuku + 50
# 内部では → Daifuku.__add__(daifuku, 50)
print(f"結果: {result}\n")

print("=" * 50)
print("テスト2: 50 + daifuku")
print("=" * 50)
try:
    result = 50 + daifuku
    # ❌ エラーになる！
except TypeError as e:
    print(f"❌ エラー: {e}")
    print(f"\n理由: int(50)は Daifukuクラスを知らない")
```

**実行結果:**
```
==================================================
テスト1: daifuku + 50
==================================================
🔵 __add__が呼ばれた！
   左側(self): 100円の大福
   右側(other): 50
結果: 150円

==================================================
テスト2: 50 + daifuku
==================================================
❌ エラー: unsupported operand type(s) for +: 'int' and 'Daifuku'

理由: int(50)は Daifukuクラスを知らない
```

---

### ステップ2️⃣：`__radd__` を追加！

```python
class Daifuku:
    def __init__(self, price):
        self.price = price
    
    def __add__(self, other):
        """
        Daifuku + 何か の計算
        左側が Daifuku の時
        """
        print(f"🔵 __add__が呼ばれた！")
        print(f"   計算式: Daifuku({self.price}) + {other}")
        return Daifuku(self.price + other)
    
    def __radd__(self, other):
        """
        何か + Daifuku の計算
        右側が Daifuku の時
        
        'r' は 'right'（右）の意味！
        """
        print(f"🔴 __radd__が呼ばれた！")
        print(f"   計算式: {other} + Daifuku({self.price})")
        # 結果は同じなので __add__ を使う
        return self.__add__(other)
    
    def __str__(self):
        return f"{self.price}円"

daifuku = Daifuku(100)

print("\n" + "=" * 50)
print("テスト1: daifuku + 50")
print("=" * 50)
result1 = daifuku + 50
# Daifukuが左側 → __add__
print(f"✅ 結果: {result1}\n")

print("=" * 50)
print("テスト2: 50 + daifuku")
print("=" * 50)
result2 = 50 + daifuku
# Daifukuが右側 → __radd__
print(f"✅ 結果: {result2}")
```

**実行結果:**
```
==================================================
テスト1: daifuku + 50
==================================================
🔵 __add__が呼ばれた！
   計算式: Daifuku(100) + 50
✅ 結果: 150円

==================================================
テスト2: 50 + daifuku
==================================================
🔴 __radd__が呼ばれた！
   計算式: 50 + Daifuku(100)
🔵 __add__が呼ばれた！
   計算式: Daifuku(100) + 50
✅ 結果: 150円
```

---

## 🧠 なぜこうなるの？内部の動きを見てみよう

### 🔍 Python内部の処理フロー

```python
# ============================================
# 50 + daifuku を実行した時の内部動作
# ============================================

"""
ステップ1️⃣: Pythonは左側のクラス(int)に聞く
   「50 + daifuku できる？」
   
   Python: int.__add__(50, daifuku) を試す
   int: 「Daifuku？知らないです」→ NotImplemented を返す
   
ステップ2️⃣: 次に右側のクラス(Daifuku)に聞く
   「じゃあ、daifuku側でできる？」
   
   Python: Daifuku.__radd__(daifuku, 50) を試す
   Daifuku: 「できます！」→ 計算を実行
   
✅ 成功！
"""

# 視覚的に理解しよう
class DebugInt:
    """int型の動作を再現したデバッグ用クラス"""
    def __init__(self, value):
        self.value = value
    
    def __add__(self, other):
        print(f"  ⚙️  DebugInt.__add__ が呼ばれた")
        print(f"     {self.value} + {other}")
        
        if isinstance(other, DebugInt):
            # 相手も DebugInt なら計算できる
            return DebugInt(self.value + other.value)
        else:
            # 知らない型なので対応できない
            print(f"     → NotImplemented（対応できない）")
            return NotImplemented

class Daifuku:
    def __init__(self, price):
        self.price = price
    
    def __radd__(self, other):
        print(f"  ✅ Daifuku.__radd__ が呼ばれた")
        print(f"     {other} + Daifuku({self.price})")
        return Daifuku(other + self.price)
    
    def __str__(self):
        return f"{self.price}円"

print("\n🔬 内部動作の観察\n")
print("=" * 50)

num = DebugInt(50)
daifuku = Daifuku(100)

print("計算: num + daifuku\n")
result = num + daifuku

print(f"\n最終結果: {result}")
```

**実行結果:**
```
🔬 内部動作の観察

==================================================
計算: num + daifuku

  ⚙️  DebugInt.__add__ が呼ばれた
     50 + 100円
     → NotImplemented（対応できない）
  ✅ Daifuku.__radd__ が呼ばれた
     50 + Daifuku(100)

最終結果: 150円
```

---

## 📊 フローチャートで理解

```python
"""
🎯 a + b を実行した時の流れ

┌─────────────┐
│  a + b 実行  │
└──────┬──────┘
       │
       ▼
┌──────────────────┐
│ a.__add__(b) 実行 │
└──────┬───────────┘
       │
       ▼
    成功？
    ┌─┴─┐
   YES  NO
    │    │
    │    ▼
    │ NotImplemented
    │    │
    │    ▼
    │ ┌──────────────────┐
    │ │ b.__radd__(a) 実行 │
    │ └──────┬───────────┘
    │        │
    │        ▼
    │     成功？
    │     ┌─┴─┐
    │    YES  NO
    │     │    │
    ▼     ▼    ▼
   結果  結果  TypeError
"""

# 実際のコードで確認
class ShowFlow:
    def __init__(self, name, value):
        self.name = name
        self.value = value
    
    def __add__(self, other):
        print(f"  📍 {self.name}.__add__ を試行")
        if isinstance(other, ShowFlow):
            print(f"     ✅ 成功！")
            return ShowFlow(f"({self.name}+{other.name})", 
                          self.value + other.value)
        else:
            print(f"     ❌ NotImplemented")
            return NotImplemented
    
    def __radd__(self, other):
        print(f"  📍 {self.name}.__radd__ を試行")
        if isinstance(other, int):
            print(f"     ✅ 成功！")
            return ShowFlow(f"({other}+{self.name})", 
                          other + self.value)
        else:
            print(f"     ❌ NotImplemented")
            return NotImplemented
    
    def __str__(self):
        return f"{self.name}={self.value}"

print("\n📊 フロー確認\n")
print("=" * 50)
print("ケース1: obj1 + obj2")
print("=" * 50)
obj1 = ShowFlow("A", 10)
obj2 = ShowFlow("B", 20)
result = obj1 + obj2
print(f"結果: {result}\n")

print("=" * 50)
print("ケース2: 5 + obj1")
print("=" * 50)
result = 5 + obj1
print(f"結果: {result}")
```

---

## 🎓 実践的な例：大福店の計算システム

```python
class Price:
    """価格クラス - 実践的な実装"""
    
    def __init__(self, yen):
        self.yen = yen
    
    def __add__(self, other):
        """
        Price + X の計算
        
        対応パターン:
        - Price + Price
        - Price + int/float
        """
        print(f"  🔵 __add__: Price({self.yen}) + {other}")
        
        if isinstance(other, Price):
            # Price + Price
            return Price(self.yen + other.yen)
        elif isinstance(other, (int, float)):
            # Price + 数値
            return Price(self.yen + other)
        else:
            # 対応していない型
            return NotImplemented
    
    def __radd__(self, other):
        """
        X + Price の計算
        
        対応パターン:
        - int/float + Price
        """
        print(f"  🔴 __radd__: {other} + Price({self.yen})")
        
        # ほとんどの場合、__add__と同じ処理でOK
        return self.__add__(other)
    
    def __str__(self):
        return f"¥{self.yen}"

# 使用例
print("\n🐰 ふわふわ大福店の会計システム\n")

daifuku_price = Price(120)
print(f"いちご大福: {daifuku_price}")

# パターン1: Price + int
print("\n【パターン1】大福 + 消費税")
with_tax = daifuku_price + 12
print(f"税込: {with_tax}\n")

# パターン2: int + Price
print("【パターン2】基本料金 + 大福")
total = 100 + daifuku_price
print(f"合計: {total}\n")

# パターン3: Price + Price
print("【パターン3】大福 + 大福")
two_daifuku = daifuku_price + Price(150)
print(f"2個分: {two_daifuku}\n")

# パターン4: 複雑な計算
print("【パターン4】複雑な計算")
result = 50 + daifuku_price + 30 + Price(80)
print(f"最終: {result}")
```

**実行結果:**
```
🐰 ふわふわ大福店の会計システム

いちご大福: ¥120

【パターン1】大福 + 消費税
  🔵 __add__: Price(120) + 12
税込: ¥132

【パターン2】基本料金 + 大福
  🔴 __radd__: 100 + Price(120)
  🔵 __add__: Price(120) + 100
合計: ¥220

【パターン3】大福 + 大福
  🔵 __add__: Price(120) + Price(150)
税込: ¥270

【パターン4】複雑な計算
  🔴 __radd__: 50 + Price(120)
  🔵 __add__: Price(120) + 50
  🔵 __add__: Price(170) + 30
  🔵 __add__: Price(200) + Price(80)
最終: ¥280
```

---

## 💡 よくある質問 Q&A

### Q1: なぜ `__radd__` の中で `self.__add__(other)` を呼ぶの？

```python
def __radd__(self, other):
    # ❓ なぜこう書く？
    return self.__add__(other)

# 🎯 答え: 足し算は順序を変えても結果が同じだから！
# 50 + Price(100) = Price(100) + 50 = 150

# だから、処理を2回書かずに __add__ を再利用する
```

### Q2: `__add__` だけじゃダメなの？

```python
# ❌ __add__ だけの場合

class Price:
    def __add__(self, other):
        return Price(self.yen + other)

p = Price(100)

p + 50    # ✅ OK → Price.__add__(p, 50)
50 + p    # ❌ エラー！ → int.__add__(50, p) は知らない

# ✅ __radd__ があれば両方OK！
```

### Q3: いつ `__radd__` を実装すべき？

```python
# 🎯 こういう時に実装する

# ✅ 実装すべき場合:
# - 数値と組み合わせて使うクラス（Price, Distance, Weight など）
# - 順序を変えても意味が同じ演算

class Distance:
    def __init__(self, meters):
        self.meters = meters
    
    def __add__(self, other):
        # Distance + 数値
        return Distance(self.meters + other)
    
    def __radd__(self, other):
        # 数値 + Distance
        return self.__add__(other)

# これで両方使える
d = Distance(100)
d + 50    # ✅ 150m
50 + d    # ✅ 150m


# ❌ 実装不要な場合:
# - 順序に意味がある演算

class Text:
    def __init__(self, content):
        self.content = content
    
    def __add__(self, other):
        # Text + 文字列（順序が重要）
        return Text(self.content + other)
    
    # __radd__ は実装しない
    # なぜなら "hello" + Text("world") は意味が違うから
```

---

## 📝 まとめ：超シンプル版

```python
# ============================================
# 🎯 これだけ覚えればOK！
# ============================================

class MyClass:
    def __init__(self, value):
        self.value = value
    
    def __add__(self, other):
        """
        MyClass + 何か
        左側が自分のクラスの時
        """
        return MyClass(self.value + other)
    
    def __radd__(self, other):
        """
        何か + MyClass
        右側が自分のクラスの時
        
        通常は __add__ を呼ぶだけでOK
        """
        return self.__add__(other)
    
    def __str__(self):
        return str(self.value)

# テスト
obj = MyClass(10)

print(obj + 5)   # __add__  → MyClass.__add__(obj, 5)
print(5 + obj)   # __radd__ → MyClass.__radd__(obj, 5)
```

---

## 🎨 視覚的まとめ

```
         左側    演算子   右側
         ────    ────    ────
ケース1:  obj  +  5     →  obj.__add__(5)  が呼ばれる
                                ▲
                                └─ 左が自分のクラス

ケース2:   5   +  obj   →  obj.__radd__(5) が呼ばれる
                                ▲
                                └─ 右が自分のクラス


💡 覚え方:
  __add__  → addの普通バージョン（左側）
  __radd__ → add の Right バージョン（右側）
             ↑
             r = right（右）の意味！
```

---

## 🐰 うさうさ店長からの最終アドバイス

```python
# ============================================
# 🎓 実装のベストプラクティス
# ============================================

class BestPractice:
    """推奨される実装パターン"""
    
    def __init__(self, value):
        self.value = value
    
    def __add__(self, other):
        """通常の加算"""
        if isinstance(other, BestPractice):
            # 同じクラス同士
            return BestPractice(self.value + other.value)
        elif isinstance(other, (int, float)):
            # 数値との計算
            return BestPractice(self.value + other)
        else:
            # 対応していない型
            return NotImplemented
    
    def __radd__(self, other):
        """逆順の加算（シンプルに）"""
        # ほとんどの場合、これで十分
        return self.__add__(other)
    
    def __str__(self):
        return f"Value({self.value})"

# 使用例
obj = BestPractice(100)

# すべて動く！
print(obj + 50)              # ✅ __add__
print(50 + obj)              # ✅ __radd__
print(obj + BestPractice(30))  # ✅ __add__
```

---

🍡 **わかったかな？**

- `obj + 5` → `__add__` が呼ばれる（左が自分）
- `5 + obj` → `__radd__` が呼ばれる（右が自分）
- `__radd__` の中身は通常 `return self.__add__(other)` でOK！

これで完璧だよ！🐰✨

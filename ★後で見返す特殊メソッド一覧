# 🐰 特殊メソッド完全ガイド - ふわふわ大福店うさうさ編

うさうさ店長が、Pythonの特殊メソッド（マジックメソッド）をわかりやすく解説するよ！

## 📚 目次
1. `__init__` と `__del__` - オブジェクトの一生
2. `__add__` と算術演算子 - 計算を自由に定義
3. `__radd__` - 逆順の計算
4. その他の便利な特殊メソッド

---

## 1️⃣ `__init__` と `__del__` - オブジェクトの誕生と終了

```python
# ============================================
# 🐰 オブジェクトのライフサイクル
# ============================================

class Daifuku:
    """大福クラス - オブジェクトの一生を追跡"""
    
    # クラス変数（全インスタンスで共有）
    total_created = 0
    # 作られた大福の総数
    
    def __init__(self, flavor, price):
        """
        コンストラクタ - オブジェクト誕生時に自動実行
        
        役割: インスタンス変数の初期化
        呼び出し: Daifuku("いちご", 120) で自動的に実行される
        """
        print(f"  🎉 {flavor}大福が誕生しました！")
        # オブジェクト作成時のメッセージ
        
        self.flavor = flavor
        # インスタンス変数（このオブジェクト固有のデータ）
        self.price = price
        # インスタンス変数（価格）
        
        Daifuku.total_created += 1
        # クラス変数を更新（全体の数をカウント）
        self.id = Daifuku.total_created
        # このオブジェクトの識別番号
        
        print(f"    （ID: {self.id}、価格: {self.price}円）")
    
    def __del__(self):
        """
        デストラクタ - オブジェクト削除時に自動実行
        
        役割: リソースの解放、後片付け
        呼び出し: del オブジェクト or プログラム終了時
        """
        print(f"  👋 {self.flavor}大福(ID:{self.id})が削除されました")
        # オブジェクト削除時のメッセージ
    
    def __str__(self):
        """
        文字列表現 - print()で呼ばれる
        """
        return f"{self.flavor}大福({self.price}円)"
        # 人間が読みやすい形式


print("🐰 === オブジェクトのライフサイクル ===\n")

# __init__が自動的に呼ばれる
d1 = Daifuku("いちご", 120)
# Daifuku.__init__(d1, "いちご", 120) が実行される

d2 = Daifuku("抹茶", 150)
# 2つ目のオブジェクト作成

print(f"\n📊 現在の大福数: {Daifuku.total_created}個")

print("\n🗑️  d1を削除します...")
del d1
# __del__が自動的に呼ばれる
# Daifuku.__del__(d1) が実行される

print("\n✅ d2はまだ存在:")
print(f"  {d2}")

print("\n🔚 プログラム終了時に残りも自動削除されます")
# プログラム終了時、d2の__del__が自動実行される
```

### 💡 `__init__` と `__del__` まとめ

| メソッド | タイミング | 主な役割 | 呼び出し方法 |
|---------|-----------|---------|------------|
| `__init__()` | インスタンス生成時 | 初期化 | 自動（`クラス名()`時） |
| `__del__()` | インスタンス削除時 | 後片付け | 自動（`del`または終了時） |

**🧁 覚え方:**
- `__init__` は「こんにちは！」（誕生）
- `__del__` は「さようなら！」（終了）

---

## 2️⃣ `__add__` - 「+」演算子を自由に定義

```python
# ============================================
# 🐰 __add__で「+」の意味を定義する
# ============================================

class Daifuku:
    """大福クラス - 加算を定義"""
    
    def __init__(self, flavor, price=120):
        """
        初期化
        """
        self.flavor = flavor
        # 味
        self.price = price
        # 価格
    
    def __add__(self, other):
        """
        加算演算子「+」の動作を定義
        
        self + other が呼ばれると、このメソッドが実行される
        
        引数:
            self: 左側のオブジェクト
            other: 右側のオブジェクト
        
        戻り値:
            新しいDaifukuオブジェクト
        """
        if isinstance(other, Daifuku):
            # otherがDaifukuクラスのインスタンスか確認
            # isinstance(オブジェクト, 型) → 型チェック
            
            new_flavor = f"{self.flavor}×{other.flavor}"
            # 2つの味を組み合わせる
            new_price = self.price + other.price
            # 価格を合算
            
            return Daifuku(new_flavor, new_price)
            # 新しい大福を作って返す
            
        elif isinstance(other, int):
            # otherが整数の場合
            
            new_price = self.price + other
            # 価格に整数を加算
            
            return Daifuku(self.flavor, new_price)
            # 同じ味で価格だけ変更
            
        else:
            # 対応していない型の場合
            return NotImplemented
            # Pythonに「この型には対応してない」と伝える
    
    def __str__(self):
        """文字列表現"""
        return f"{self.flavor}大福({self.price}円)"


print("\n🐰 === __add__の使い方 ===\n")

# 大福を2つ作る
d1 = Daifuku("いちご", 120)
print(f"d1 = {d1}")

d2 = Daifuku("抹茶", 150)
print(f"d2 = {d2}")

# 🎯 ここがポイント！
# d1 + d2 を書くと、内部で Daifuku.__add__(d1, d2) が呼ばれる
print("\n➕ d1 + d2 を実行:")
d3 = d1 + d2
# これは Daifuku.__add__(d1, d2) と同じ
print(f"結果: {d3}")

# 大福 + 整数
print("\n➕ d1 + 30 を実行:")
d4 = d1 + 30
# これは Daifuku.__add__(d1, 30) と同じ
print(f"結果: {d4}")


# ============================================
# 🍰 実用例：お会計クラス
# ============================================

class Bill:
    """お会計クラス"""
    
    def __init__(self, amount):
        """
        金額を初期化
        """
        self.amount = amount
        # 金額
    
    def __add__(self, other):
        """
        Bill + Bill または Bill + int/float の加算
        """
        if isinstance(other, Bill):
            # 2つのお会計を合算
            return Bill(self.amount + other.amount)
        elif isinstance(other, (int, float)):
            # お会計に金額を追加
            # (int, float) はタプルで複数の型を指定
            return Bill(self.amount + other)
        else:
            return NotImplemented
    
    def __str__(self):
        """文字列表現"""
        return f"¥{self.amount:,}"
        # :, は3桁区切りのカンマ


print("\n\n🐰 === お会計の計算 ===\n")

bill1 = Bill(1200)
print(f"お客様A: {bill1}")

bill2 = Bill(850)
print(f"お客様B: {bill2}")

# 2つのお会計を合算
total = bill1 + bill2
print(f"\n合計: {total}")

# お会計に消費税を追加
with_tax = total + 205
print(f"税込: {with_tax}")
```

---

## 3️⃣ `__radd__` - 逆順の加算（右側加算）

```python
# ============================================
# 🐰 __radd__で「逆順の+」に対応
# ============================================

class Price:
    """価格クラス - 逆順の加算にも対応"""
    
    def __init__(self, yen):
        """金額を初期化"""
        self.yen = yen
    
    def __add__(self, other):
        """
        通常の加算: Price + 何か
        
        self + other の場合に呼ばれる
        """
        print(f"  🔵 __add__が呼ばれました")
        
        if isinstance(other, Price):
            # Price + Price
            return Price(self.yen + other.yen)
        elif isinstance(other, (int, float)):
            # Price + 数値
            return Price(self.yen + other)
        else:
            return NotImplemented
    
    def __radd__(self, other):
        """
        逆順の加算: 何か + Price
        
        other + self の場合に呼ばれる
        左側が組み込み型（int, floatなど）の時に実行される
        
        🎯 重要ポイント:
        - 普通、int + int はPythonが処理する
        - でも、int + Price はintクラスが対応していない
        - そこで、Priceの__radd__が呼ばれる！
        """
        print(f"  🔴 __radd__が呼ばれました")
        
        # 多くの場合、__add__と同じ処理でOK
        return self.__add__(other)
        # self.__add__(other) を呼び出す
        # つまり、順序を入れ替えて__add__を使う
    
    def __str__(self):
        """文字列表現"""
        return f"{self.yen}円"


print("\n🐰 === __add__ と __radd__ の違い ===\n")

p = Price(100)
print(f"価格オブジェクト: {p}\n")

# ケース1: Price + int
print("📌 ケース1: p + 50")
result1 = p + 50
# Price.__add__(p, 50) が呼ばれる
print(f"結果: {result1}\n")

# ケース2: int + Price
print("📌 ケース2: 50 + p")
result2 = 50 + p
# 内部の動き:
# 1. まず、int.__add__(50, p) を試みる
# 2. intクラスはPriceを知らないのでNotImplementedを返す
# 3. 次に、Price.__radd__(p, 50) が呼ばれる
print(f"結果: {result2}\n")

# ケース3: Price + Price
print("📌 ケース3: p + Price(30)")
result3 = p + Price(30)
# Price.__add__(p, Price(30)) が呼ばれる
print(f"結果: {result3}\n")


# ============================================
# 🎓 __radd__がないとどうなる？
# ============================================

class PriceNoRAdd:
    """__radd__がない価格クラス"""
    
    def __init__(self, yen):
        self.yen = yen
    
    def __add__(self, other):
        """通常の加算のみ"""
        if isinstance(other, PriceNoRAdd):
            return PriceNoRAdd(self.yen + other.yen)
        elif isinstance(other, (int, float)):
            return PriceNoRAdd(self.yen + other)
        return NotImplemented
    
    def __str__(self):
        return f"{self.yen}円"


print("\n🐰 === __radd__がない場合 ===\n")

p2 = PriceNoRAdd(100)

# これは動く
print("✅ p2 + 50:")
print(f"  {p2 + 50}")

# これはエラーになる！
print("\n❌ 50 + p2:")
try:
    print(f"  {50 + p2}")
except TypeError as e:
    print(f"  エラー: {e}")
    print(f"  理由: __radd__がないので、int + PriceNoRAddに対応できない")
```

### 🎯 `__add__` と `__radd__` の使い分け

```python
# ============================================
# 📊 まとめ：いつどちらが呼ばれる？
# ============================================

class Demo:
    def __init__(self, value):
        self.value = value
    
    def __add__(self, other):
        print(f"    __add__: Demo({self.value}) + {other}")
        return Demo(self.value + other)
    
    def __radd__(self, other):
        print(f"    __radd__: {other} + Demo({self.value})")
        return Demo(other + self.value)
    
    def __str__(self):
        return f"Demo({self.value})"


print("\n\n🐰 === 呼び出されるメソッドの一覧 ===\n")

d = Demo(10)

print("1️⃣  d + 5:")
print(f"  → {d + 5}\n")

print("2️⃣  5 + d:")
print(f"  → {5 + d}\n")

print("3️⃣  d + Demo(3):")
d2 = Demo(3)
print(f"  → {d + d2}\n")
```

### 📋 呼び出しルール表

| 式 | 最初に試みる | 失敗したら | 結果 |
|---|-----------|---------|-----|
| `a + b` | `a.__add__(b)` | `b.__radd__(a)` | どちらかが成功 |
| `100 + obj` | `int.__add__(100, obj)` → 失敗 | `obj.__radd__(100)` | `__radd__`が呼ばれる |
| `obj + 100` | `obj.__add__(100)` | （通常不要） | `__add__`が呼ばれる |

---

## 4️⃣ その他の便利な特殊メソッド

```python
# ============================================
# 🐰 よく使う特殊メソッド集
# ============================================

class DaifukuShop:
    """大福ショップクラス - 様々な特殊メソッド"""
    
    def __init__(self, items):
        """初期化"""
        self.items = items
        # 商品リスト
    
    def __str__(self):
        """
        文字列表現 - print()で使われる
        人間が読みやすい形式
        """
        return f"大福ショップ（商品数: {len(self.items)}）"
    
    def __repr__(self):
        """
        開発者向け表現 - デバッグ時に使われる
        再現可能な形式が望ましい
        """
        return f"DaifukuShop({self.items})"
    
    def __len__(self):
        """
        長さ - len()で使われる
        """
        return len(self.items)
    
    def __getitem__(self, index):
        """
        インデックスアクセス - shop[0]で使われる
        """
        return self.items[index]
    
    def __setitem__(self, index, value):
        """
        インデックス代入 - shop[0] = "新商品"で使われる
        """
        self.items[index] = value
    
    def __contains__(self, item):
        """
        メンバーシップテスト - "いちご" in shopで使われる
        """
        return item in self.items
    
    def __eq__(self, other):
        """
        等価比較 - shop1 == shop2で使われる
        """
        if isinstance(other, DaifukuShop):
            return self.items == other.items
        return False
    
    def __lt__(self, other):
        """
        小なり比較 - shop1 < shop2で使われる
        商品数で比較
        """
        if isinstance(other, DaifukuShop):
            return len(self.items) < len(other.items)
        return NotImplemented
    
    def __add__(self, other):
        """
        加算 - shop1 + shop2で使われる
        2つのショップを統合
        """
        if isinstance(other, DaifukuShop):
            return DaifukuShop(self.items + other.items)
        return NotImplemented


print("\n🐰 === 特殊メソッドの実演 ===\n")

shop1 = DaifukuShop(["いちご", "抹茶", "あんこ"])
shop2 = DaifukuShop(["栗", "チョコ"])

# __str__
print("📝 __str__（print時）:")
print(f"  {shop1}\n")

# __repr__
print("🔧 __repr__（開発者向け）:")
print(f"  {repr(shop1)}\n")

# __len__
print("📏 __len__（長さ）:")
print(f"  len(shop1) = {len(shop1)}\n")

# __getitem__
print("📋 __getitem__（インデックスアクセス）:")
print(f"  shop1[0] = {shop1[0]}\n")

# __setitem__
print("✏️  __setitem__（インデックス代入）:")
shop1[0] = "特選いちご"
print(f"  shop1[0] = '{shop1[0]}'\n")

# __contains__
print("🔍 __contains__（メンバーシップ）:")
print(f"  '抹茶' in shop1 = {'抹茶' in shop1}\n")

# __eq__
print("⚖️  __eq__（等価比較）:")
shop3 = DaifukuShop(["特選いちご", "抹茶", "あんこ"])
print(f"  shop1 == shop3 = {shop1 == shop3}\n")

# __lt__
print("📊 __lt__（小なり比較）:")
print(f"  shop2 < shop1 = {shop2 < shop1}")
print(f"  （shop2の商品数: {len(shop2)}, shop1の商品数: {len(shop1)}）\n")

# __add__
print("➕ __add__（加算）:")
combined = shop1 + shop2
print(f"  shop1 + shop2 = {combined}")
print(f"  商品一覧: {combined.items}\n")
```

---

## 📊 主要な特殊メソッド一覧表

| カテゴリ | メソッド | 用途 | 例 |
|---------|---------|-----|---|
| **初期化・削除** | `__init__` | インスタンス初期化 | `obj = Class()` |
| | `__del__` | インスタンス削除 | `del obj` |
| **文字列表現** | `__str__` | 人間向け文字列 | `print(obj)` |
| | `__repr__` | 開発者向け文字列 | `repr(obj)` |
| **算術演算** | `__add__` | 加算 | `a + b` |
| | `__radd__` | 右側加算 | `5 + obj` |
| | `__sub__` | 減算 | `a - b` |
| | `__mul__` | 乗算 | `a * b` |
| | `__truediv__` | 除算 | `a / b` |
| **比較演算** | `__eq__` | 等価 | `a == b` |
| | `__ne__` | 不等価 | `a != b` |
| | `__lt__` | 小なり | `a < b` |
| | `__le__` | 以下 | `a <= b` |
| | `__gt__` | 大なり | `a > b` |
| | `__ge__` | 以上 | `a >= b` |
| **コンテナ** | `__len__` | 長さ | `len(obj)` |
| | `__getitem__` | 取得 | `obj[key]` |
| | `__setitem__` | 設定 | `obj[key] = val` |
| | `__contains__` | 含有 | `x in obj` |

---

## 🎯 学習のまとめ

### 🧁 覚えておきたいポイント

1. **`__init__`**: オブジェクト誕生時の「こんにちは」
2. **`__del__`**: オブジェクト削除時の「さようなら」
3. **`__add__`**: `+`演算子の動作を自分で定義できる
4. **`__radd__`**: 逆順（`数値 + オブジェクト`）にも対応
5. **特殊メソッド**: Pythonの演算子や組み込み関数を自作クラスで使えるようにする仕組み

### 💡 実践的な使い方

```python
# 実用的な例：お買い物カート
class Cart:
    def __init__(self):
        self.items = []
    
    def __add__(self, item):
        """商品を追加"""
        self.items.append(item)
        return self
    
    def __len__(self):
        """商品数"""
        return len(self.items)
    
    def __str__(self):
        """カート内容"""
        return f"カート({len(self)}点): {', '.join(self.items)}"

cart = Cart()
cart = cart + "いちご大福" + "抹茶大福"
print(cart)
```

🐰 **うさうさ店長より**: 特殊メソッドを使いこなせば、Pythonらしい綺麗なコードが書けるようになるよ！🍡✨
